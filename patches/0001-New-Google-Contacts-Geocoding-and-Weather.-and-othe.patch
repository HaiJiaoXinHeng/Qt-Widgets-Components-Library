From 123e89d702e12dcf00ef2ede13d5f7f26464a091 Mon Sep 17 00:00:00 2001
Message-Id: <123e89d702e12dcf00ef2ede13d5f7f26464a091.1248412462.git.mbertozzi@norsk.(none)>
From: Matteo Bertozzi <mbertozzi@norsk.(none)>
Date: Thu, 23 Jul 2009 22:03:36 -0700
Subject: [PATCH] New Google Contacts, Geocoding and Weather. and other fixes

---
 Google/Google.pro                          |   38 +
 Google/src/googleauth.cpp                  |    6 +-
 Google/src/googleauth.h                    |    6 +-
 Google/src/googlecontacts.cpp              | 1870 ++++++++++++++++++++++++++++
 Google/src/googlecontacts.h                |  463 +++++++
 Google/src/googledetectlanguage.cpp        |    4 +-
 Google/src/googleentry.cpp                 |  917 ++++++++++++++
 Google/src/googleentry.h                   |  311 +++++
 Google/src/googlegeocoding.cpp             |  274 ++++
 Google/src/googlegeocoding.h               |   79 ++
 Google/src/googleservice.cpp               |   54 +-
 Google/src/googleservice.h                 |   17 +-
 Google/src/googletranslator.cpp            |    5 +-
 Google/src/googleweather.cpp               |  341 +++++
 Google/src/googleweather.h                 |  101 ++
 Google/tests/ContactsTest/ContactsTest.pro |   17 +
 Google/tests/ContactsTest/chess.jpg        |  Bin 0 -> 3346 bytes
 Google/tests/ContactsTest/contactstest.cpp |  196 +++
 Google/tests/ContactsTest/contactstest.h   |   39 +
 Google/tests/ServicesTest/ServicesTest.pro |   17 +
 Google/tests/ServicesTest/servicestest.cpp |  164 +++
 Google/tests/ServicesTest/servicestest.h   |   25 +
 22 files changed, 4913 insertions(+), 31 deletions(-)

diff --git a/Google/Google.pro b/Google/Google.pro
new file mode 100644
index 0000000..7ffcd09
--- /dev/null
+++ b/Google/Google.pro
@@ -0,0 +1,38 @@
+######################################################################
+# Automatically generated by qmake (2.01a) Tue Jun 9 07:15:53 2009
+######################################################################
+
+TEMPLATE = lib
+TARGET = THGoogle
+DESTDIR = lib
+
+OBJECTS_DIR = tmp
+MOC_DIR = tmp
+
+DEPENDPATH += . src tests
+INCLUDEPATH += . src 
+QT += network xml 
+
+# Input
+HEADERS += src/googleauth.h \
+           src/googlecontacts.h \
+           src/googledetectlanguage.h \
+           src/googleentry.h \
+           src/googlegeocoding.h \
+           src/googleservice.h \
+           src/googlespellchecker.h \
+           src/googlesuggest.h \
+           src/googletranslator.h \
+           src/googleweather.h \
+           src/jsonstreamreader.h
+SOURCES += src/googleauth.cpp \
+           src/googlecontacts.cpp \
+           src/googledetectlanguage.cpp \
+           src/googleentry.cpp \
+           src/googlegeocoding.cpp \
+           src/googleservice.cpp \
+           src/googlespellchecker.cpp \
+           src/googlesuggest.cpp \
+           src/googletranslator.cpp \
+           src/googleweather.cpp \
+           src/jsonstreamreader.cpp 
diff --git a/Google/src/googleauth.cpp b/Google/src/googleauth.cpp
index d39b6d9..b29f777 100644
--- a/Google/src/googleauth.cpp
+++ b/Google/src/googleauth.cpp
@@ -181,15 +181,15 @@ QString THGoogleAuth::errorString (void) const {
 	return(d->errorMessage());
 }
 
-const QString& THGoogleAuth::sid (void) const {
+QString THGoogleAuth::sid (void) const {
 	return(d->sid);
 }
 
-const QString& THGoogleAuth::lsid (void) const {
+QString THGoogleAuth::lsid (void) const {
 	return(d->lsid);
 }
 
-const QString& THGoogleAuth::auth (void) const {
+QString THGoogleAuth::auth (void) const {
 	return(d->auth);
 }
 
diff --git a/Google/src/googleauth.h b/Google/src/googleauth.h
index 4ae4c01..13ed6f2 100644
--- a/Google/src/googleauth.h
+++ b/Google/src/googleauth.h
@@ -89,9 +89,9 @@ class THGoogleAuth : public QObject {
 		Error error (void) const;
 		QString errorString (void) const;
 
-		const QString& sid (void) const;
-		const QString& lsid (void) const;
-		const QString& auth (void) const;
+		QString sid (void) const;
+		QString lsid (void) const;
+		QString auth (void) const;
 
 	Q_SIGNALS:
 		void authenticated (bool error = false);
diff --git a/Google/src/googlecontacts.cpp b/Google/src/googlecontacts.cpp
new file mode 100644
index 0000000..3c4001e
--- /dev/null
+++ b/Google/src/googlecontacts.cpp
@@ -0,0 +1,1870 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <QXmlStreamReader>
+#include <QXmlStreamWriter>
+#include <QNetworkReply>
+#include <QEventLoop>
+#include <QBuffer>
+#include <QPixmap>
+#include <QImage>
+#include <QTimer>
+#include <QHash>
+#include <QUrl>
+
+#include "googlecontacts.h"
+
+// ===========================================================================
+//  EMail
+// ===========================================================================
+class THGoogleEmailPrivate {
+    public:
+        QString displayName;
+        QString address;
+        QString label;
+        QString quota;
+        bool primary;
+        QString rel;
+};
+
+THGoogleEmail::THGoogleEmail (QObject *parent)
+    : QObject(parent), d(new THGoogleEmailPrivate)
+{
+    d->primary = false;
+}
+
+THGoogleEmail::~THGoogleEmail() {
+    delete d;
+}
+
+
+QString THGoogleEmail::relHome (void) {
+    return("http://schemas.google.com/g/2005#home");
+}
+
+QString THGoogleEmail::relWork (void) {
+    return("http://schemas.google.com/g/2005#work");
+}
+
+QString THGoogleEmail::relOther (void) {
+    return("http://schemas.google.com/g/2005#other");
+}
+
+void THGoogleEmail::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    if (attributes.hasAttribute("address"))
+        d->address = attributes.value("address").toString().simplified();
+
+    if (attributes.hasAttribute("label"))
+        d->address = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("primary"))
+        d->primary = attributes.value("primary").compare("true", Qt::CaseInsensitive);
+}
+
+void THGoogleEmail::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    if (!d->address.isEmpty())
+        xmlWriter->writeAttribute("address", d->address);
+
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    xmlWriter->writeAttribute("primary", d->primary ? "true" : "false");
+}
+
+QString THGoogleEmail::label (void) const {
+    return(d->label);
+}
+
+void THGoogleEmail::setLabel (const QString& label) {
+    d->label = label;
+}
+
+QString THGoogleEmail::address (void) const {
+    return(d->address);
+}
+
+void THGoogleEmail::setAddress (const QString& address) {
+    d->address = address;
+}
+
+bool THGoogleEmail::isWorkAddress (void) const {
+    return(d->rel == relWork());
+}
+
+bool THGoogleEmail::isHomeAddress (void) const {
+    return(d->rel == relHome());
+}
+
+bool THGoogleEmail::isOtherAddress (void) const {
+    return(d->rel == relOther());
+}
+
+QString THGoogleEmail::displayName (void) const {
+    return(d->displayName);
+}
+
+void THGoogleEmail::setDisplayName (const QString& displayName) {
+    d->displayName = displayName;
+}
+
+bool THGoogleEmail::primary (void) const {
+    return(d->primary);
+}
+
+void THGoogleEmail::setPrimary (bool primary) {
+    d->primary = primary;
+}
+
+QString THGoogleEmail::rel (void) const {
+    return(d->rel);
+}
+
+void THGoogleEmail::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+QString THGoogleEmail::quota (void) const {
+    return(d->quota);
+}
+
+void THGoogleEmail::setQuota (const QString& quota) {
+    d->quota = quota;
+}
+
+// ===========================================================================
+//  Group Membership Info
+// ===========================================================================
+class THGoogleGroupMembershipInfoPrivate {
+    public:
+        QString href;
+        bool deleted;
+};
+
+THGoogleGroupMembershipInfo::THGoogleGroupMembershipInfo (QObject *parent)
+    : QObject(parent), d(new THGoogleGroupMembershipInfoPrivate)
+{
+}
+
+THGoogleGroupMembershipInfo::~THGoogleGroupMembershipInfo() {
+    delete d;
+}
+
+void THGoogleGroupMembershipInfo::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("href"))
+        d->href = attributes.value("href").toString().simplified();
+
+    if (attributes.hasAttribute("deleted"))
+        d->deleted = attributes.value("deleted").compare("true", Qt::CaseInsensitive);
+}
+
+void THGoogleGroupMembershipInfo::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->href.isEmpty())
+        xmlWriter->writeAttribute("href", d->href);
+
+    xmlWriter->writeAttribute("deleted", d->deleted ? "true" : "false");
+}
+
+bool THGoogleGroupMembershipInfo::deleted (void) const {
+    return(d->deleted);
+}
+
+void THGoogleGroupMembershipInfo::setDeleted (bool deleted) {
+    d->deleted = deleted;
+}
+
+bool THGoogleGroupMembershipInfo::hasHref (void) const {
+    return(!d->href.isEmpty());
+}
+
+QString THGoogleGroupMembershipInfo::href (void) const {
+    return(d->href);
+}
+
+void THGoogleGroupMembershipInfo::setHref (const QString& href) {
+    d->href = href;
+}
+
+// ===========================================================================
+//  Instant Messaging
+// ===========================================================================
+class THGoogleImPrivate {
+    public:
+        QString protocol;
+        QString address;
+        QString label;
+        bool primary;
+        QString rel;
+};
+
+THGoogleIm::THGoogleIm (QObject *parent)
+    : QObject(parent), d(new THGoogleImPrivate)
+{
+}
+
+THGoogleIm::~THGoogleIm() {
+    delete d;
+}
+
+
+QString THGoogleIm::relHome (void) {
+    return("http://schemas.google.com/g/2005#home");
+}
+
+QString THGoogleIm::relWork (void) {
+    return("http://schemas.google.com/g/2005#work");
+}
+
+QString THGoogleIm::relOther (void) {
+    return("http://schemas.google.com/g/2005#other");
+}
+
+QString THGoogleIm::protocolQq (void) {
+    return("http://schemas.google.com/g/2005#QQ");
+}
+
+QString THGoogleIm::protocolAim (void) {
+    return("http://schemas.google.com/g/2005#AIM");
+}
+
+QString THGoogleIm::protocolMsn (void) {
+    return("http://schemas.google.com/g/2005#MSN");
+}
+
+QString THGoogleIm::protocolIcq (void) {
+    return("http://schemas.google.com/g/2005#ICQ");
+}
+
+QString THGoogleIm::protocolYahoo (void) {
+    return("http://schemas.google.com/g/2005#YAHOO");
+}
+
+QString THGoogleIm::protocolSkype (void) {
+    return("http://schemas.google.com/g/2005#SKYPE");
+}
+
+QString THGoogleIm::protocolJabber (void) {
+    return("http://schemas.google.com/g/2005#JABBER");
+}
+
+QString THGoogleIm::protocolGoogleTalk (void) {
+    return("http://schemas.google.com/g/2005#GOOGLE_TALK");
+}
+
+
+void THGoogleIm::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("address"))
+        d->address = attributes.value("address").toString().simplified();
+
+    if (attributes.hasAttribute("protocol"))
+        d->protocol = attributes.value("protocol").toString().simplified();
+
+    if (attributes.hasAttribute("label"))
+        d->label = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("primary"))
+        d->primary = attributes.value("primary").compare("true", Qt::CaseInsensitive);
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+}
+
+void THGoogleIm::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    if (!d->protocol.isEmpty())
+        xmlWriter->writeAttribute("protocol", d->protocol);
+
+    if (!d->address.isEmpty())
+        xmlWriter->writeAttribute("address", d->address);
+
+    xmlWriter->writeAttribute("primary", d->primary ? "true" : "false");
+}
+
+bool THGoogleIm::hasAddress (void) const {
+    return(!d->address.isEmpty());
+}
+
+QString THGoogleIm::address (void) const {
+    return(d->address);
+}
+
+void THGoogleIm::setAddress (const QString& address) {
+    d->address = address;
+}
+
+bool THGoogleIm::isWorkAddress (void) const {
+    return(d->rel == relWork());
+}
+
+bool THGoogleIm::isHomeAddress (void) const {
+    return(d->rel == relHome());
+}
+
+bool THGoogleIm::isOtherAddress (void) const {
+    return(d->rel == relOther());
+}
+
+bool THGoogleIm::hasLabel (void) const {
+    return(!d->label.isEmpty());
+}
+
+QString THGoogleIm::label (void) const {
+    return(d->label);
+}
+
+void THGoogleIm::setLabel (const QString& label) {
+    d->label = label;
+}
+
+
+bool THGoogleIm::primary (void) const {
+    return(d->primary);
+}
+
+void THGoogleIm::setPrimary (bool primary) {
+    d->primary = primary;
+}
+
+
+bool THGoogleIm::hasProtocol (void) const {
+    return(!d->protocol.isEmpty());
+}
+
+QString THGoogleIm::protocol (void) const {
+    return(d->protocol);
+}
+
+void THGoogleIm::setProtocol (const QString& protocol) {
+    d->protocol = protocol;
+}
+
+
+bool THGoogleIm::hasRel (void) const {
+    return(!d->rel.isEmpty());
+}
+
+QString THGoogleIm::rel (void) const {
+    return(d->rel);
+}
+
+void THGoogleIm::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+// ===========================================================================
+//  Organization
+// ===========================================================================
+class THGoogleOrganizationPrivate {
+    public:
+        QString orgTitle;
+        QString orgName;
+        QString label;
+        bool primary;
+        QString rel;
+};
+
+
+THGoogleOrganization::THGoogleOrganization (QObject *parent)
+    : QObject(parent), d(new THGoogleOrganizationPrivate)
+{
+}
+
+THGoogleOrganization::~THGoogleOrganization() {
+    delete d;
+}
+
+void THGoogleOrganization::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("label"))
+        d->label = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    if (attributes.hasAttribute("primary"))
+        d->primary = attributes.value("primary").compare("true", Qt::CaseInsensitive);
+
+    while (!xmlReader->atEnd()) {
+        xmlReader->readNext();
+
+        QStringRef name = xmlReader->qualifiedName();
+        if (xmlReader->isEndElement() && name == "gd:organization")        
+            break;        
+
+        if (!xmlReader->isStartElement())
+            continue;
+
+        if (name == "gd:orgName")
+            d->orgName = xmlReader->readElementText().simplified();
+        else if (name == "gd:orgTitle")
+            d->orgTitle = xmlReader->readElementText().simplified();
+    }
+}
+
+void THGoogleOrganization::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    xmlWriter->writeAttribute("primary", d->primary ? "true" : "false");
+
+    xmlWriter->writeTextElement("gd:orgName", d->orgName);
+    xmlWriter->writeTextElement("gd:orgTitle", d->orgTitle);
+}
+
+bool THGoogleOrganization::hasLabel (void) const {
+    return(!d->label.isEmpty());
+}
+
+QString THGoogleOrganization::label (void) const {
+    return(d->label);
+}
+
+void THGoogleOrganization::setLabel (const QString& label) {
+    d->label = label;
+}
+
+
+bool THGoogleOrganization::hasOrgName (void) const {
+    return(!d->orgName.isEmpty());
+}
+
+QString THGoogleOrganization::orgName (void) const {
+    return(d->orgName);
+}
+
+void THGoogleOrganization::setOrgName (const QString& orgName) {
+    d->orgName = orgName;
+}
+
+
+bool THGoogleOrganization::hasOrgTitle (void) const {
+    return(!d->orgTitle.isEmpty());
+}
+
+QString THGoogleOrganization::orgTitle (void) const {
+    return(d->orgTitle);
+}
+
+void THGoogleOrganization::setOrgTitle (const QString& orgTitle) {
+    d->orgTitle = orgTitle;
+}
+
+
+bool THGoogleOrganization::primary (void) {
+    return(d->primary);
+}
+
+void THGoogleOrganization::setPrimary (bool primary) {
+    d->primary = primary;
+}
+
+
+bool THGoogleOrganization::hasRel (void) const {
+    return(!d->rel.isEmpty());
+}
+
+QString THGoogleOrganization::rel (void) const {
+    return(d->rel);
+}
+
+void THGoogleOrganization::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+// ===========================================================================
+//  Phone Number
+// ===========================================================================
+class THGooglePhoneNumberPrivate {
+    public:
+        QString phoneNumber;
+        QString label;
+        bool primary;
+        QString uri;
+        QString rel;
+};
+
+THGooglePhoneNumber::THGooglePhoneNumber (QObject *parent)
+    : QObject(parent), d(new THGooglePhoneNumberPrivate)
+{
+    d->primary = false;
+}
+
+THGooglePhoneNumber::~THGooglePhoneNumber() {
+    delete d;
+}
+
+void THGooglePhoneNumber::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("label"))
+        d->label = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    if (attributes.hasAttribute("uri"))
+        d->uri = attributes.value("uri").toString().simplified();
+
+    if (attributes.hasAttribute("primary"))
+        d->primary = attributes.value("primary").compare("true", Qt::CaseInsensitive);
+
+    d->phoneNumber = xmlReader->readElementText().simplified();
+}
+
+void THGooglePhoneNumber::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    if (!d->uri.isEmpty())
+        xmlWriter->writeAttribute("uri", d->uri);
+
+    xmlWriter->writeAttribute("primary", d->primary ? "true" : "false");
+    xmlWriter->writeCharacters(d->phoneNumber);
+}
+
+QString THGooglePhoneNumber::label (void) const {
+    return(d->label);
+}
+
+void THGooglePhoneNumber::setLabel (const QString& label) {
+    d->label = label;
+}
+
+
+QString THGooglePhoneNumber::phoneNumber (void) const {
+    return(d->phoneNumber);
+}
+
+void THGooglePhoneNumber::setPhoneNumber (const QString& phoneNumber) {
+    d->phoneNumber = phoneNumber;
+}
+
+
+bool THGooglePhoneNumber::primary (void) const {
+    return(d->primary);
+}
+
+void THGooglePhoneNumber::setPrimary (bool primary) {
+    d->primary = primary;
+}
+
+
+QString THGooglePhoneNumber::rel (void) const {
+    return(d->rel);
+}
+
+void THGooglePhoneNumber::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+
+QString THGooglePhoneNumber::uri (void) const {
+    return(d->uri);
+}
+
+void THGooglePhoneNumber::setUri (const QString& uri) {
+    d->uri = uri;
+}
+
+// ===========================================================================
+//  Postal Address
+// ===========================================================================
+class THGooglePostalAddressPrivate {
+    public:
+        QString formattedAddress;
+        QString postCode;
+        QString country;
+        QString address;
+        QString region;
+        QString city;
+
+        QString label;
+        bool primary;
+        QString rel;
+};
+
+THGooglePostalAddress::THGooglePostalAddress (QObject *parent)
+    : QObject(parent), d(new THGooglePostalAddressPrivate)
+{
+    d->primary = false;
+}
+
+THGooglePostalAddress::~THGooglePostalAddress() {
+    delete d;
+}
+
+void THGooglePostalAddress::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("primary"))
+        d->primary = attributes.value("primary").compare("true", Qt::CaseInsensitive);
+
+    if (attributes.hasAttribute("label"))
+        d->label = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    while (xmlReader->atEnd()) {
+        xmlReader->readNext();
+
+        QStringRef name = xmlReader->qualifiedName();
+        if (xmlReader->isEndElement() && name == "gd:structuredPostalAddress")        
+            break;        
+
+        if (!xmlReader->isStartElement())
+            continue;
+
+        if (name == "gd:formattedAddress")
+            d->formattedAddress = xmlReader->readElementText().simplified();
+        else if (name == "gd:postCode")
+            d->postCode = xmlReader->readElementText().simplified();
+        else if (name == "gd:country")
+            d->country = xmlReader->readElementText().simplified();
+        else if (name == "gd:address")
+            d->address = xmlReader->readElementText().simplified();
+        else if (name == "gd:region")
+            d->region = xmlReader->readElementText().simplified();
+        else if (name == "gd:city")
+            d->city = xmlReader->readElementText().simplified();
+        else if (name == "gd:postCode")
+            d->postCode = xmlReader->readElementText().simplified();
+    }
+}
+
+void THGooglePostalAddress::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    xmlWriter->writeAttribute("primary", d->primary ? "true" : "false");
+
+    if (!d->formattedAddress.isEmpty())
+        xmlWriter->writeTextElement("gd:formattedAddress", d->formattedAddress);
+
+    if (!d->postCode.isEmpty())
+        xmlWriter->writeTextElement("gd:postCode", d->postCode);
+
+    if (!d->country.isEmpty())
+        xmlWriter->writeTextElement("gd:country", d->country);
+
+    if (!d->address.isEmpty())
+        xmlWriter->writeTextElement("gd:address", d->address);
+
+    if (!d->region.isEmpty())
+        xmlWriter->writeTextElement("gd:region", d->region);
+
+    if (!d->city.isEmpty())
+        xmlWriter->writeTextElement("gd:city", d->city);
+
+    if (!d->postCode.isEmpty())
+        xmlWriter->writeTextElement("gd:postCode", d->postCode);
+}
+
+QString THGooglePostalAddress::label (void) const {
+    return(d->label);
+}
+
+void THGooglePostalAddress::setLabel (const QString& label) {
+    d->label = label;
+}
+
+bool THGooglePostalAddress::primary (void) const {
+    return(d->primary);
+}
+
+void THGooglePostalAddress::setPrimary (bool primary) {
+    d->primary = primary;
+}
+
+
+QString THGooglePostalAddress::rel (void) const {
+    return(d->rel);
+}
+
+void THGooglePostalAddress::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+QString THGooglePostalAddress::city (void) const {
+    return(d->city);
+}
+
+void THGooglePostalAddress::setCity (const QString& city) {
+    d->city = city;
+}
+
+QString THGooglePostalAddress::region (void) const {
+    return(d->region);
+}
+
+void THGooglePostalAddress::setRegion (const QString& region) {
+    d->region = region;
+}
+
+QString THGooglePostalAddress::address (void) const {
+    return(d->address);
+}
+
+void THGooglePostalAddress::setAddress (const QString& address) {
+    d->address = address;
+}
+
+QString THGooglePostalAddress::country (void) const {
+    return(d->country);
+}
+
+void THGooglePostalAddress::setCountry (const QString& country) {
+    d->country = country;
+}
+
+QString THGooglePostalAddress::postCode (void) const {
+    return(d->postCode);
+}
+
+void THGooglePostalAddress::setPostCode (const QString& postCode) {
+    d->postCode = postCode;
+}
+
+QString THGooglePostalAddress::formattedAddress (void) const {
+    return(d->formattedAddress);
+}
+
+void THGooglePostalAddress::setFormattedAddress (const QString& address) {
+    d->formattedAddress = address;
+}
+
+// ===========================================================================
+//  Contact WebSite
+// ===========================================================================
+class THGoogleContactWebSitePrivate {
+    public:
+        QString label;
+        bool primary;
+        QString href;
+        QString rel;
+};
+
+THGoogleContactWebSite::THGoogleContactWebSite (QObject *parent)
+    : QObject(parent), d(new THGoogleContactWebSitePrivate)
+{
+    d->primary = false;
+}
+
+THGoogleContactWebSite::~THGoogleContactWebSite() {
+    delete d;
+}
+
+QString THGoogleContactWebSite::relHomePage (void) {
+    return("home-page");
+}
+
+QString THGoogleContactWebSite::relProfile (void) {
+    return("profile");
+}
+
+QString THGoogleContactWebSite::relOther (void) {
+    return("other");
+}
+
+QString THGoogleContactWebSite::relBlog (void) {
+    return("blog");
+}
+
+QString THGoogleContactWebSite::relHome (void) {
+    return("home");
+}
+
+QString THGoogleContactWebSite::relWork (void) {
+    return("work");
+}
+
+QString THGoogleContactWebSite::relFtp (void) {
+    return("ftp");
+}
+
+void THGoogleContactWebSite::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("label"))
+        d->label = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    if (attributes.hasAttribute("href"))
+        d->href = attributes.value("href").toString().simplified();
+
+    if (attributes.hasAttribute("primary"))
+        d->primary = attributes.value("primary").compare("true", Qt::CaseInsensitive);
+}
+
+void THGoogleContactWebSite::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    xmlWriter->writeAttribute("primary", d->primary ? "true" : "false");
+    xmlWriter->writeAttribute("href", d->href);
+}
+
+bool THGoogleContactWebSite::hasRel (void) const {
+    return(!d->rel.isEmpty());
+}
+
+QString THGoogleContactWebSite::rel (void) const {
+    return(d->rel);
+}
+       
+void THGoogleContactWebSite::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+bool THGoogleContactWebSite::hasHref (void) const {
+    return(!d->href.isEmpty());
+}
+
+QString THGoogleContactWebSite::href (void) const {
+    return(d->href);
+}
+
+void THGoogleContactWebSite::setHref (const QString& href) {
+    d->href = href;
+}
+
+bool THGoogleContactWebSite::hasLabel (void) const {
+    return(!d->label.isEmpty());
+}
+
+QString THGoogleContactWebSite::label (void) const {
+    return(d->label);
+}
+
+void THGoogleContactWebSite::setLabel (const QString& label) {
+    d->label = label;
+}
+
+bool THGoogleContactWebSite::primary (void) const {
+    return(d->primary);
+}
+
+void THGoogleContactWebSite::setPrimary (bool primary) {
+    d->primary = primary;
+}
+
+// ===========================================================================
+//  Contact External ID
+// ===========================================================================
+THGoogleContactExternalId::THGoogleContactExternalId (QObject *parent)
+    : THGoogleRelValueInfo(parent)
+{
+}
+
+THGoogleContactExternalId::~THGoogleContactExternalId() {
+}
+
+// ===========================================================================
+//  Contact Group Entry
+// ===========================================================================
+class THGoogleContactGroupPrivate {
+    public:
+        QString systemGroupId;
+};
+
+THGoogleContactGroup::THGoogleContactGroup (QObject *parent)
+    : THGoogleEntry(parent), d(new THGoogleContactGroupPrivate)
+{
+    category()->setScheme("http://schemas.google.com/g/2005#kind");
+    category()->setTerm("http://schemas.google.com/contact/2008#group");
+}
+
+THGoogleContactGroup::~THGoogleContactGroup() {
+    delete d;
+}
+
+QString THGoogleContactGroup::systemGroupIdCoworkers (void) {
+    return("Coworkers");
+}
+
+QString THGoogleContactGroup::systemGroupIdContacts (void) {
+    return("Contacts");
+}
+
+QString THGoogleContactGroup::systemGroupIdFriends (void) {
+    return("Friends");
+}
+
+QString THGoogleContactGroup::systemGroupIdFamily (void) {
+    return("Family");
+}
+
+QString THGoogleContactGroup::systemGroupId (void) const {
+    return(d->systemGroupId);
+}
+
+void THGoogleContactGroup::setSystemGroupId (const QString& groupId) {
+    d->systemGroupId = groupId;
+}
+
+bool THGoogleContactGroup::readXmlElement (QXmlStreamReader *xmlReader) {
+    QStringRef name = xmlReader->qualifiedName();
+
+    if (name == "gContact:systemGroup") {
+        QXmlStreamAttributes attributes = xmlReader->attributes();
+        if (attributes.hasAttribute("id"))
+            d->systemGroupId = attributes.value("id").toString().simplified();
+        return(true);
+    }
+
+    return(false);
+}
+
+void THGoogleContactGroup::writeXmlElement (QXmlStreamWriter *xmlWriter) const {
+    if (!d->systemGroupId.isEmpty()) {
+        xmlWriter->writeEmptyElement("gContact:systemGroup");
+        xmlWriter->writeAttribute("id", d->systemGroupId);
+    }
+}
+
+// ===========================================================================
+//  Contact Entry
+// ===========================================================================
+class THGoogleContactPrivate {
+    public:
+        QList<THGoogleGroupMembershipInfo *> groupMembershipInfos;
+        QList<THGoogleContactUserField> userDefinedFields;
+        QList<THGoogleContactExternalId *> externalIds;
+        QList<THGooglePostalAddress *> postalAddresses;
+        QList<THGoogleOrganization *> organizations;
+        QList<THGooglePhoneNumber *> phoneNumbers;
+        QList<THGoogleContactWebSite *> webSites;
+        QList<THGoogleEmail *> emailAddresses;
+        QList<THGoogleIm *> imAddresses;
+
+        THGoogleLink *editPhotoLink;
+        THGoogleLink *photoLink;
+
+        QString familyName;
+        QString givenName;
+        QString fullName;
+};
+
+THGoogleContact::THGoogleContact (QObject *parent)
+    : THGoogleEntry(parent), d(new THGoogleContactPrivate)
+{
+    d->editPhotoLink = NULL;
+    d->photoLink = NULL;
+    addAdapter(this);
+
+    // Setup Category
+    category()->setScheme("http://schemas.google.com/g/2005#kind");
+    category()->setTerm("http://schemas.google.com/contact/2008#contact");
+}
+
+THGoogleContact::~THGoogleContact() {
+    delete d;
+}
+
+void THGoogleContact::clear (void) {
+    THGoogleEntry::clear();
+
+    d->groupMembershipInfos.clear();
+    d->userDefinedFields.clear();
+    d->postalAddresses.clear();
+    d->emailAddresses.clear();
+    d->organizations.clear();
+    d->phoneNumbers.clear();
+    d->externalIds.clear();
+    d->imAddresses.clear();
+
+    if (d->editPhotoLink != NULL) {
+        d->editPhotoLink->deleteLater();
+        d->editPhotoLink = NULL;
+    }
+
+    if (d->photoLink != NULL) {
+        d->photoLink->deleteLater();
+        d->photoLink = NULL;
+    }
+
+    d->familyName.clear();
+    d->givenName.clear();
+    d->fullName.clear();
+}
+
+bool THGoogleContact::readXmlElement (QXmlStreamReader *xmlReader) {
+    QStringRef name = xmlReader->qualifiedName();
+
+    if (name == "gd:im") {
+        THGoogleIm *imAddress = new THGoogleIm(this);
+        imAddress->readXml(xmlReader);
+        d->imAddresses.append(imAddress);
+        return(true);
+    } else if (name == "gd:email") {
+        THGoogleEmail *emailAddress = new THGoogleEmail(this);
+        emailAddress->readXml(xmlReader);
+        d->emailAddresses.append(emailAddress);
+        return(true);
+    } else if (name == "gd:phoneNumber") {
+        THGooglePhoneNumber *phoneNumber = new THGooglePhoneNumber(this);
+        phoneNumber->readXml(xmlReader);
+        d->phoneNumbers.append(phoneNumber);
+        return(true);
+    } else if (name == "gd:organization") {
+        THGoogleOrganization *organization = new THGoogleOrganization(this);
+        organization->readXml(xmlReader);
+        d->organizations.append(organization);
+        return(true);
+    } else if (name == "gd:structuredPostalAddress") {
+        THGooglePostalAddress *postalAddress = new THGooglePostalAddress(this);
+        postalAddress->readXml(xmlReader);
+        d->postalAddresses.append(postalAddress);
+        return(true);
+    } else if (name == "gd:fullName") {
+        d->fullName = xmlReader->readElementText().simplified();
+        return(true);
+    } else if (name == "gd:familyName") {
+        d->familyName = xmlReader->readElementText().simplified();
+        return(true);
+    } else if (name == "gd:givenName") {
+        d->givenName = xmlReader->readElementText().simplified();
+        return(true);
+    } else if (name == "gContact:groupMembershipInfo") {
+        THGoogleGroupMembershipInfo *info = new THGoogleGroupMembershipInfo(this);
+        info->readXml(xmlReader);
+        d->groupMembershipInfos.append(info);
+        return(true);
+    } else if (name == "gContact:userDefinedField") {
+        QXmlStreamAttributes attributes = xmlReader->attributes();
+        if (!attributes.hasAttribute("key") || !attributes.hasAttribute("value"))
+            return(false);
+
+        QString key = attributes.value("key").toString();
+        QString value = attributes.value("value").toString();
+        d->userDefinedFields.append(THGoogleContactUserField(key, value));
+        return(true);
+    } else if (name == "gContact:website") {
+        THGoogleContactWebSite *webSite = new THGoogleContactWebSite(this);
+        webSite->readXml(xmlReader);
+        d->webSites.append(webSite);
+        return(true);
+    } else if (name == "gContact:externalId") {
+        THGoogleContactExternalId *externalId = new THGoogleContactExternalId(this);
+        externalId->readXml(xmlReader);
+        d->externalIds.append(externalId);
+        return(true);
+    }
+
+    return(false);
+}
+
+void THGoogleContact::writeXmlElement (QXmlStreamWriter *xmlWriter) const {
+    foreach (THGoogleEmail *email, d->emailAddresses) {
+        xmlWriter->writeStartElement("gd:email");
+        email->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGoogleIm *im, d->imAddresses) {
+        xmlWriter->writeStartElement("gd:im");
+        im->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGoogleGroupMembershipInfo *groupInfo, d->groupMembershipInfos) {
+        xmlWriter->writeStartElement("gContact:groupMembershipInfo");
+        groupInfo->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGooglePostalAddress *postalAddress, d->postalAddresses) {
+        xmlWriter->writeStartElement("gd:structuredPostalAddress");
+        postalAddress->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGoogleOrganization *organization, d->organizations) {
+        xmlWriter->writeStartElement("gd:organization");
+        organization->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGooglePhoneNumber *phoneNumber, d->phoneNumbers) {
+        xmlWriter->writeStartElement("gd:phoneNumber");
+        phoneNumber->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGoogleContactUserField field, d->userDefinedFields) {
+        xmlWriter->writeStartElement("gContact:userDefinedField");
+        xmlWriter->writeAttribute("key", field.first);
+        xmlWriter->writeAttribute("value", field.second);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGoogleContactWebSite *webSite, d->webSites) {
+        xmlWriter->writeEmptyElement("gContact:webSite");
+        webSite->writeXml(xmlWriter);
+    } 
+
+    foreach (THGoogleContactExternalId *externalId, d->externalIds) {
+        xmlWriter->writeEmptyElement("gContact:externalId");        
+        externalId->writeXml(xmlWriter);
+    }
+
+    xmlWriter->writeStartElement("gd:name");
+    if (!d->fullName.isEmpty())
+        xmlWriter->writeTextElement("gd:fullName", d->fullName);
+
+    if (!d->givenName.isEmpty())
+        xmlWriter->writeTextElement("gd:givenName", d->givenName);
+
+    if (!d->familyName.isEmpty())
+        xmlWriter->writeTextElement("gd:familyName", d->familyName);
+    xmlWriter->writeEndElement();
+}
+
+void THGoogleContact::addImAddress (THGoogleIm *imAddress) {
+    imAddress->setParent(this);
+    d->imAddresses.append(imAddress);
+}
+
+void THGoogleContact::addEmailAddress (THGoogleEmail *emailAddress) {
+    emailAddress->setParent(this);
+    d->emailAddresses.append(emailAddress);
+}
+
+void THGoogleContact::addPhoneNumber (THGooglePhoneNumber *phoneNumber) {
+    phoneNumber->setParent(this);
+    d->phoneNumbers.append(phoneNumber);
+}
+
+void THGoogleContact::addOrganization (THGoogleOrganization *organization) {
+    organization->setParent(this);
+    d->organizations.append(organization);
+}
+
+void THGoogleContact::addPostalAddress (THGooglePostalAddress *postalAddress) {
+    postalAddress->setParent(this);
+    d->postalAddresses.append(postalAddress);
+}
+
+void THGoogleContact::addUserDefinedField (const QString& key, const QString& value) {
+    d->userDefinedFields.append(THGoogleContactUserField(key, value));
+}
+
+void THGoogleContact::addGroupMembershipInfo (THGoogleGroupMembershipInfo *membershipInfo) {
+    membershipInfo->setParent(this);
+    d->groupMembershipInfos.append(membershipInfo);
+}
+
+QString THGoogleContact::fullName (void) const {
+    if (d->fullName.isEmpty())
+        return(title());
+    return(d->fullName);
+}
+
+void THGoogleContact::setFullName (const QString& fullName) {
+    d->fullName = fullName;
+}
+
+QString THGoogleContact::givenName (void) const {
+    return(d->givenName);
+}
+
+void THGoogleContact::setGivenName (const QString& givenName) {
+    d->givenName = givenName;
+}
+
+QString THGoogleContact::familyName (void) const {
+    return(d->familyName);
+}
+
+void THGoogleContact::setFamilyName (const QString& familyName) {
+    d->familyName = familyName;
+}
+
+
+QList<THGoogleIm *> THGoogleContact::imAddresses (void) const {
+    return(d->imAddresses);
+}
+
+QList<THGoogleEmail *> THGoogleContact::emailAddresses (void) const {
+    return(d->emailAddresses);
+}
+
+QList<THGooglePhoneNumber *> THGoogleContact::phoneNumbers (void) const {
+    return(d->phoneNumbers);
+}
+
+QList<THGoogleOrganization *> THGoogleContact::organizations (void) const {
+    return(d->organizations);
+}
+
+QList<THGooglePostalAddress *> THGoogleContact::postalAddresses (void) const {
+    return(d->postalAddresses);
+}
+
+QList<THGoogleContactExternalId *> THGoogleContact::externalIds (void) const {
+    return(d->externalIds);
+}
+
+QList<THGoogleContactUserField> THGoogleContact::userDefinedFields (void) const {
+    return(d->userDefinedFields);
+}
+
+QList<THGoogleGroupMembershipInfo *> THGoogleContact::groupMembershipInfos (void) const {
+    return(d->groupMembershipInfos);
+}
+
+bool THGoogleContact::hasImAddresses (void) const {
+    return(!d->imAddresses.isEmpty());
+}
+
+bool THGoogleContact::hasPhoneNumbers (void) const {
+    return(!d->phoneNumbers.isEmpty());
+}
+
+bool THGoogleContact::hasOrganizations (void) const {
+    return(!d->organizations.isEmpty());
+}
+
+bool THGoogleContact::hasPostalAddresses (void) const {
+    return(!d->postalAddresses.isEmpty());
+}
+
+bool THGoogleContact::hasEmailAddresses (void) const {
+    return(!d->emailAddresses.isEmpty());
+}
+
+bool THGoogleContact::hasGroupMembershipInfos (void) const {
+    return(!d->groupMembershipInfos.isEmpty());
+}
+
+bool THGoogleContact::hasPhoto (void) const {
+    return(photoLink() != NULL && photoLink()->hasEtag());
+}
+
+bool THGoogleContact::hasPhotoLink (void) const {
+    return(photoLink() != NULL);
+}
+
+THGoogleLink *THGoogleContact::photoLink (void) const {
+    if (d->photoLink == NULL)
+        d->photoLink = link(relPhoto(), "image/*");
+    return(d->photoLink);
+}
+
+bool THGoogleContact::hasEditPhoto (void) const {
+    return(photoLink() != NULL && photoLink()->hasEtag());
+}
+
+bool THGoogleContact::hasEditPhotoLink (void) const {
+    return(editPhotoLink() != NULL);
+}
+
+THGoogleLink *THGoogleContact::editPhotoLink (void) const {
+    if (d->editPhotoLink == NULL)
+        d->editPhotoLink = link(relEditPhoto(), "image/*");
+    return(d->editPhotoLink);
+}
+
+// STATIC Methods
+QString THGoogleContact::relPhoto (void) {
+    return("http://schemas.google.com/contacts/2008/rel#photo");
+}
+
+QString THGoogleContact::relEditPhoto (void) {
+    return("http://schemas.google.com/contacts/2008/rel#edit-photo");
+}
+
+// ========================================================================
+//  Contacts Service (Executer)
+// ========================================================================
+
+#include <QDebug>
+class THGoogleContactService {
+    public:
+        enum RequestType { 
+            InsertContact, UpdateContact, DeleteContact, RefreshContact, 
+            UpdateContactPhoto, UpdateContactPhotoEdit,
+            InsertGroup, UpdateGroup, DeleteGroup, RefreshGroup,
+            RetrievingContacts, RetrievingGroups
+        };
+
+    public:
+        THGoogleContactService (RequestType requestType);
+        THGoogleContactService (THGoogleEntry *entity, 
+                                RequestType requestType);
+        ~THGoogleContactService();
+
+        void run (THGoogleContactsService *service, QNetworkReply *reply);
+
+    private:
+        void parseInsertContactResponse (THGoogleContactsService *service);
+        void parseUpdateContactResponse (THGoogleContactsService *service);
+        void parseDeleteContactResponse (THGoogleContactsService *service);
+        void parseRefreshContactResponse (THGoogleContactsService *service);
+        void parseUpdateContactPhotoResponse (THGoogleContactsService *service);
+        void parseUpdateContactPhotoEditResponse (THGoogleContactsService *service);
+
+        void parseInsertGroupResponse (THGoogleContactsService *service);
+        void parseUpdateGroupResponse (THGoogleContactsService *service);
+        void parseDeleteGroupResponse (THGoogleContactsService *service);
+        void parseRefreshGroupResponse (THGoogleContactsService *service);
+
+        void parseRetrievingGroupsResponse (THGoogleContactsService *service);
+        void parseRetrievingContactsResponse (THGoogleContactsService *service);
+
+    private:
+        THGoogleEntry *m_entry;
+        RequestType m_requestType;
+        QNetworkReply *m_reply;
+};
+
+THGoogleContactService::THGoogleContactService (RequestType requestType) {
+    m_requestType = requestType;
+    m_entry = NULL;
+}
+
+THGoogleContactService::THGoogleContactService (THGoogleEntry *entity,
+                                                RequestType requestType)
+{
+    m_requestType = requestType;
+    m_entry = entity;
+}
+
+THGoogleContactService::~THGoogleContactService() {
+}
+
+void THGoogleContactService::run (THGoogleContactsService *service, 
+                                  QNetworkReply *reply)
+{
+    m_reply = reply;
+
+    // Check if Response is Valid
+    int statusCode = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
+    if (statusCode != 200 && statusCode != 201) {
+        service->setErrorString(reply->readAll());
+        emit service->finished(false);
+        return;
+    }
+
+    switch (m_requestType) {
+        case InsertContact:
+            parseInsertContactResponse(service);
+            return;
+        case UpdateContact:
+            parseUpdateContactResponse(service);
+            return;
+        case DeleteContact:
+            parseDeleteContactResponse(service);
+            return;
+        case RefreshContact:
+            parseRefreshContactResponse(service);
+            return;
+        case UpdateContactPhoto:
+            parseUpdateContactPhotoResponse(service);
+            return;
+        case UpdateContactPhotoEdit:
+            parseUpdateContactPhotoEditResponse(service);
+            return;
+        case InsertGroup:
+            parseInsertGroupResponse(service);
+            return;
+        case UpdateGroup:
+            parseUpdateGroupResponse(service);
+            return;
+        case DeleteGroup:
+            parseDeleteGroupResponse(service);
+            return;
+        case RefreshGroup:
+            parseRefreshGroupResponse(service);
+            return;
+        case RetrievingGroups:
+            parseRetrievingGroupsResponse(service);
+            return;
+        case RetrievingContacts:
+            parseRetrievingContactsResponse(service);
+            return;
+    }
+
+    emit service->finished(true);
+}
+
+void THGoogleContactService::parseInsertContactResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(false);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry") {
+                m_entry->clear();
+                m_entry->readXml(&xmlReader);
+            }
+        }
+
+        service->refreshContact(static_cast<THGoogleContact *>(m_entry));
+    }
+}
+
+void THGoogleContactService::parseUpdateContactResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry")
+                m_entry->readXml(&xmlReader);
+        }
+
+        service->refreshContact(static_cast<THGoogleContact *>(m_entry));
+    }
+}
+
+void THGoogleContactService::parseDeleteContactResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        emit service->finished(false);
+    }
+}
+
+void THGoogleContactService::parseRefreshContactResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry") {
+                m_entry->clear();
+                m_entry->readXml(&xmlReader);
+            }
+        }
+
+        emit service->finished(false);
+    }
+}
+
+void THGoogleContactService::parseUpdateContactPhotoResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry")
+                m_entry->readXml(&xmlReader);
+        }
+
+        service->refreshContact(static_cast<THGoogleContact *>(m_entry));
+    }
+}
+
+void THGoogleContactService::parseUpdateContactPhotoEditResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry")
+                m_entry->readXml(&xmlReader);
+        }
+
+        service->refreshContact(static_cast<THGoogleContact *>(m_entry));
+    }
+}
+
+void THGoogleContactService::parseInsertGroupResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry") {
+                m_entry->clear();
+                m_entry->readXml(&xmlReader);
+            }
+        }
+
+        service->refreshGroup(static_cast<THGoogleContactGroup *>(m_entry));
+    }
+}
+
+void THGoogleContactService::parseUpdateGroupResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry")
+                m_entry->readXml(&xmlReader);
+        }
+
+        service->refreshGroup(static_cast<THGoogleContactGroup *>(m_entry));
+    }
+}
+
+void THGoogleContactService::parseDeleteGroupResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        emit service->finished(false);
+    }
+}
+
+void THGoogleContactService::parseRefreshGroupResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry") {
+                m_entry->clear();
+                m_entry->readXml(&xmlReader);
+            }
+        }
+
+        emit service->finished(false);
+    }
+}
+
+void THGoogleContactService::parseRetrievingGroupsResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QList<THGoogleContactGroup *> groupList;
+
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry") {
+                THGoogleContactGroup *group = new THGoogleContactGroup;
+                groupList.append(group);
+
+                group->readXml(&xmlReader);
+            }
+        }
+
+        emit service->finished(false);
+        service->setGroupList(groupList);
+    }
+}
+
+void THGoogleContactService::parseRetrievingContactsResponse (THGoogleContactsService *service) {
+    QByteArray data = m_reply->readAll();
+    if (data.trimmed().isEmpty()) {
+        emit service->finished(true);
+    } else {
+        QList<THGoogleContact *> contactList;
+
+        QXmlStreamReader xmlReader(data);
+        while (!xmlReader.atEnd()) {
+            xmlReader.readNext();
+
+            if (xmlReader.name() == "entry") {
+                THGoogleContact *contact = new THGoogleContact;
+                contactList.append(contact);
+
+                contact->readXml(&xmlReader);
+            }
+        }
+
+        emit service->finished(false);
+        service->setContactList(contactList);
+    }
+}
+
+// ========================================================================
+//  Contacts Service
+// ========================================================================
+class THGoogleContactsServicePrivate {
+    public:
+        QHash<QNetworkReply *, THGoogleContactService *> requests;
+        QList<THGoogleContactGroup *> groups;
+        QList<THGoogleContact *> contacts;
+};
+
+THGoogleContactsService::THGoogleContactsService (QObject *parent)
+    : THGooglEntryService(parent), d(new THGoogleContactsServicePrivate)
+{
+    setGDataVersion("3.0");
+}
+
+THGoogleContactsService::~THGoogleContactsService() {
+}
+
+void THGoogleContactsService::insertContact (THGoogleContact *contact) {
+    QUrl url("http://www.google.com/m8/feeds/contacts/default/full");
+    QNetworkReply *reply = insertEntry(url, contact->toXml());
+
+    THGoogleContactService *service = new THGoogleContactService(contact,   
+                                         THGoogleContactService::InsertContact);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::updateContact (THGoogleContact *contact) {
+    THGoogleLink *editLink = contact->link("edit", "application/atom+xml");
+    QNetworkReply *reply = updateEntry(QUrl::fromEncoded(editLink->href().toLatin1()),
+                                       contact->etag().toLatin1(),
+                                       contact->toXml());
+
+    THGoogleContactService *service = new THGoogleContactService(contact,   
+                                         THGoogleContactService::UpdateContact);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::deleteContact (THGoogleContact *contact) {
+    QNetworkReply *reply = deleteEntry(QUrl::fromEncoded(contact->id().toLatin1()),
+                                       contact->etag().toLatin1(),
+                                       contact->toXml());
+
+    THGoogleContactService *service = new THGoogleContactService(contact,   
+                                           THGoogleContactService::DeleteContact);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::refreshContact (THGoogleContact *contact) {
+    THGoogleLink *selfLink = contact->link("self", "application/atom+xml");
+    refreshContact(contact, QUrl::fromEncoded(selfLink->href().toLatin1()));
+}
+
+void THGoogleContactsService::refreshContact (THGoogleContact *contact, const QUrl& url) {
+    QNetworkReply *reply = queryEntry(url);
+    THGoogleContactService *service = new THGoogleContactService(contact,   
+                                       THGoogleContactService::RefreshContact);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::addContactPhoto (THGoogleContact *contact, 
+                                               const QImage& image)
+{
+    QByteArray data;
+    QBuffer buffer(&data);
+    buffer.open(QIODevice::WriteOnly);
+    image.save(&buffer, "PNG");
+
+    addContactPhoto(contact, data);
+}
+
+void THGoogleContactsService::addContactPhoto (THGoogleContact *contact, 
+                                               const QPixmap& pixmap)
+{
+    QByteArray data;
+    QBuffer buffer(&data);
+    buffer.open(QIODevice::WriteOnly);
+    pixmap.save(&buffer, "PNG");
+
+    addContactPhoto(contact, data);
+}
+
+void THGoogleContactsService::addContactPhoto (THGoogleContact *contact, 
+                                               const QByteArray& pngData)
+{
+    QUrl url = QUrl::fromEncoded(contact->photoLink()->href().toLatin1());
+
+    QNetworkRequest request(url);
+    request.setHeader(QNetworkRequest::ContentTypeHeader, "image/png");
+    request.setRawHeader("If-Match", "*");
+
+    QNetworkReply *reply = updateEntry(request, pngData);
+    THGoogleContactService *service = new THGoogleContactService(contact,   
+                                   THGoogleContactService::UpdateContactPhoto);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::addContactEditPhoto (THGoogleContact *contact, 
+                                                   const QImage& image)
+{
+    QByteArray data;
+    QBuffer buffer(&data);
+    buffer.open(QIODevice::WriteOnly);
+    image.save(&buffer, "PNG");
+    addContactEditPhoto(contact, data);
+}
+
+void THGoogleContactsService::addContactEditPhoto (THGoogleContact *contact, 
+                                                   const QPixmap& pixmap)
+{
+    QByteArray data;
+    QBuffer buffer(&data);
+    buffer.open(QIODevice::WriteOnly);
+    pixmap.save(&buffer, "PNG");
+    addContactEditPhoto(contact, data);
+}
+
+void THGoogleContactsService::addContactEditPhoto (THGoogleContact *contact, 
+                                                   const QByteArray& pngData)
+{
+    QUrl url = QUrl::fromEncoded(contact->editPhotoLink()->href().toLatin1());
+    QNetworkRequest request(url);
+    request.setHeader(QNetworkRequest::ContentTypeHeader, "image/png");
+    request.setRawHeader("If-Match", "*");
+
+    QNetworkReply *reply = updateEntry(request, pngData);
+    THGoogleContactService *service = new THGoogleContactService(contact,   
+                              THGoogleContactService::UpdateContactPhotoEdit);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::insertGroup (THGoogleContactGroup *group) {
+    QUrl url("http://www.google.com/m8/feeds/groups/default/full");
+    QNetworkReply *reply = insertEntry(url, group->toXml());
+
+    THGoogleContactService *service = new THGoogleContactService(group,   
+                                         THGoogleContactService::InsertGroup);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::updateGroup (THGoogleContactGroup *group) {
+    THGoogleLink *editLink = group->link("edit", "application/atom+xml");
+    QNetworkReply *reply = updateEntry(QUrl::fromEncoded(editLink->href().toLatin1()),
+                                       group->etag().toLatin1(),
+                                       group->toXml());
+
+    THGoogleContactService *service = new THGoogleContactService(group,   
+                                         THGoogleContactService::UpdateGroup);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::deleteGroup (THGoogleContactGroup *group) {
+    QNetworkReply *reply = deleteEntry(QUrl::fromEncoded(group->id().toLatin1()),
+                                       group->etag().toLatin1(),
+                                       group->toXml());
+
+    THGoogleContactService *service = new THGoogleContactService(group,   
+                                           THGoogleContactService::DeleteGroup);
+    d->requests.insert(reply, service);
+}
+
+void THGoogleContactsService::refreshGroup (THGoogleContactGroup *group) {
+    THGoogleLink *selfLink = group->link("self", "application/atom+xml");
+    refreshGroup(group, QUrl::fromEncoded(selfLink->href().toLatin1()));
+}
+
+void THGoogleContactsService::refreshGroup (THGoogleContactGroup *group, const QUrl& url) {
+    QNetworkReply *reply = queryEntry(url);
+    THGoogleContactService *service = new THGoogleContactService(group,   
+                                       THGoogleContactService::RefreshGroup);
+    d->requests.insert(reply, service);
+}
+
+//http://www.google.com/m8/feeds/contacts/default/projection
+//http://www.google.com/m8/feeds/contacts/default/full
+void THGoogleContactsService::retrieveAllContacts (void) {
+    QNetworkReply *reply = queryEntry(QUrl("http://www.google.com/m8/feeds/contacts/default/full"));
+
+    THGoogleContactService *service = new THGoogleContactService(   
+                                       THGoogleContactService::RetrievingContacts);
+    d->requests.insert(reply, service);
+}
+
+
+//http://www.google.com/m8/feeds/groups/default/projection
+//http://www.google.com/m8/feeds/groups/default/full
+void THGoogleContactsService::retrieveAllGroups (void) {
+    QNetworkReply *reply = queryEntry(QUrl("http://www.google.com/m8/feeds/groups/default/full"));
+    THGoogleContactService *service = new THGoogleContactService(   
+                                       THGoogleContactService::RetrievingGroups);
+    d->requests.insert(reply, service);
+}
+
+QList<THGoogleContact *> THGoogleContactsService::contactList (void) const {
+    return(d->contacts);
+}
+
+QList<THGoogleContactGroup *> THGoogleContactsService::groupList (void) const {
+    return(d->groups);
+}
+
+void THGoogleContactsService::parseResponse (QNetworkReply *reply) {
+    if (!d->requests.contains(reply)) {
+        THGooglEntryService::parseResponse(reply);
+        return;
+    }
+
+    THGoogleContactService *service = d->requests.take(reply);
+    service->run(this, reply);
+}
+
+void THGoogleContactsService::setContactList (const QList<THGoogleContact *>& contacts) {
+    // TODO: Free Prev List
+    d->contacts = contacts;
+}
+
+void THGoogleContactsService::setGroupList (const QList<THGoogleContactGroup *>& groups) {
+    // TODO: Free Prev List
+    d->groups = groups;
+}
+
+
diff --git a/Google/src/googlecontacts.h b/Google/src/googlecontacts.h
new file mode 100644
index 0000000..34b24ea
--- /dev/null
+++ b/Google/src/googlecontacts.h
@@ -0,0 +1,463 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _GOOGLECONTACTS_H_
+#define _GOOGLECONTACTS_H_
+
+#include <QPair>
+class QXmlStreamReader;
+class QXmlStreamWriter;
+class QPixmap;
+class QImage;
+
+#include "googleentry.h"
+
+class THGoogleEmailPrivate;
+class THGoogleEmail : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleEmail (QObject *parent = 0);
+        ~THGoogleEmail();
+
+        // Static Methods
+        static QString relHome (void);
+        static QString relWork (void);
+        static QString relOther (void);
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        QString address (void) const;
+        void setAddress (const QString& address);
+
+        bool isWorkAddress (void) const;
+        bool isHomeAddress (void) const;
+        bool isOtherAddress (void) const;
+
+        QString displayName (void) const;
+        void setDisplayName (const QString& displayName);
+
+        bool primary (void) const;
+        void setPrimary (bool primary);
+
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+        QString quota (void) const;
+        void setQuota (const QString& quota);
+
+    private:
+        THGoogleEmailPrivate *d;
+};
+
+class THGoogleGroupMembershipInfoPrivate;
+class THGoogleGroupMembershipInfo : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleGroupMembershipInfo (QObject *parent = 0);
+        ~THGoogleGroupMembershipInfo();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool deleted (void) const;
+        void setDeleted (bool deleted);
+
+        bool hasHref (void) const;
+        QString href (void) const;
+        void setHref (const QString& href);
+
+    private:
+        THGoogleGroupMembershipInfoPrivate *d;
+};
+
+class THGoogleImPrivate;
+class THGoogleIm : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleIm (QObject *parent = 0);
+        ~THGoogleIm();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Static Methods
+        static QString relHome (void);
+        static QString relWork (void);
+        static QString relOther (void);
+
+        static QString protocolQq (void);
+        static QString protocolAim (void);
+        static QString protocolMsn (void);
+        static QString protocolIcq (void);
+        static QString protocolYahoo (void);
+        static QString protocolSkype (void);
+        static QString protocolJabber (void);
+        static QString protocolGoogleTalk (void);
+
+        // Properties
+        bool hasAddress (void) const;
+        QString address (void) const;
+        void setAddress (const QString& address);
+
+        bool isWorkAddress (void) const;
+        bool isHomeAddress (void) const;
+        bool isOtherAddress (void) const;
+
+        bool hasLabel (void) const;
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        bool primary (void) const;
+        void setPrimary (bool primary);
+
+        bool hasProtocol (void) const;
+        QString protocol (void) const;
+        void setProtocol (const QString& protocol);
+
+        bool hasRel (void) const;
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+    private:
+        THGoogleImPrivate *d;
+};
+
+class THGoogleOrganizationPrivate;
+class THGoogleOrganization : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleOrganization (QObject *parent = 0);
+        ~THGoogleOrganization();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool hasLabel (void) const;
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        bool hasOrgName (void) const;
+        QString orgName (void) const;
+        void setOrgName (const QString& orgName);
+
+        bool hasOrgTitle (void) const;        
+        QString orgTitle (void) const;
+        void setOrgTitle (const QString& orgTitle);
+
+        bool primary (void);
+        void setPrimary (bool primary);
+
+        bool hasRel (void) const;
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+    private:
+        THGoogleOrganizationPrivate *d;
+};
+
+class THGooglePhoneNumberPrivate;
+class THGooglePhoneNumber : public QObject {
+    Q_OBJECT
+
+    public:
+        THGooglePhoneNumber (QObject *parent = 0);
+        ~THGooglePhoneNumber();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        QString phoneNumber (void) const;
+        void setPhoneNumber (const QString& phoneNumber);
+
+        bool primary (void) const;
+        void setPrimary (bool primary);
+
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+        QString uri (void) const;
+        void setUri (const QString& uri);
+
+    private:
+        THGooglePhoneNumberPrivate *d;
+};
+
+class THGooglePostalAddressPrivate;
+class THGooglePostalAddress : public QObject {
+    Q_OBJECT
+
+    public:
+        THGooglePostalAddress (QObject *parent = 0);
+        ~THGooglePostalAddress();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        bool primary (void) const;
+        void setPrimary (bool primary);
+
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+        QString city (void) const;
+        void setCity (const QString& city);
+
+        QString region (void) const;
+        void setRegion (const QString& region);
+
+        QString address (void) const;
+        void setAddress (const QString& address);
+
+        QString country (void) const;
+        void setCountry (const QString& country);
+
+        QString postCode (void) const;
+        void setPostCode (const QString& postCode);
+
+        QString formattedAddress (void) const;
+        void setFormattedAddress (const QString& address);
+
+    private:
+        THGooglePostalAddressPrivate *d;
+};
+
+class THGoogleContactWebSitePrivate;
+class THGoogleContactWebSite : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleContactWebSite (QObject *parent = 0);
+        ~THGoogleContactWebSite();
+
+        // Static Methods
+        static QString relHomePage (void);
+        static QString relProfile (void);
+        static QString relOther (void);
+        static QString relBlog (void);
+        static QString relHome (void);
+        static QString relWork (void);
+        static QString relFtp (void);
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool hasRel (void) const;
+        QString rel (void) const;       
+        void setRel (const QString& rel);
+
+        bool hasHref (void) const;
+        QString href (void) const;
+        void setHref (const QString& href);
+
+        bool hasLabel (void) const;
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        bool primary (void) const;
+        void setPrimary (bool primary);
+
+    private:
+        THGoogleContactWebSitePrivate *d;
+};
+
+class THGoogleContactExternalId : public THGoogleRelValueInfo {
+    Q_OBJECT
+
+    public:
+        THGoogleContactExternalId (QObject *parent = 0);
+        ~THGoogleContactExternalId();
+};
+
+class THGoogleContactGroupPrivate;
+class THGoogleContactGroup : public THGoogleEntry, public THGoogleEntryAdapter {
+    Q_OBJECT
+
+    public:
+        THGoogleContactGroup (QObject *parent = 0);
+        ~THGoogleContactGroup();
+
+        // Static Methods
+        static QString systemGroupIdCoworkers (void);
+        static QString systemGroupIdContacts (void);
+        static QString systemGroupIdFriends (void);
+        static QString systemGroupIdFamily (void);
+
+        // Properties
+        QString systemGroupId (void) const;
+        void setSystemGroupId (const QString& groupId);
+
+    public:
+        bool readXmlElement (QXmlStreamReader *xmlReader);
+        void writeXmlElement (QXmlStreamWriter *xmlWriter) const;
+
+    private:
+        THGoogleContactGroupPrivate *d;
+};
+
+typedef QPair<QString, QString> THGoogleContactUserField;
+
+class THGoogleContactPrivate;
+class THGoogleContact : public THGoogleEntry, public THGoogleEntryAdapter {
+    Q_OBJECT
+
+    public:
+        THGoogleContact (QObject *parent = 0);
+        ~THGoogleContact();
+
+        virtual void clear (void);
+
+        void addImAddress (THGoogleIm *address);
+        void addEmailAddress (THGoogleEmail *address);
+        void addPhoneNumber (THGooglePhoneNumber *phoneNumber);
+        void addOrganization (THGoogleOrganization *organization);
+        void addPostalAddress (THGooglePostalAddress *postalAddress);
+        void addUserDefinedField (const QString& key, const QString& value);
+        void addGroupMembershipInfo (THGoogleGroupMembershipInfo *membershipInfo);
+
+        //void declareExtension (THGoogleExtensionProfile *extensionProfile);
+
+        QString fullName (void) const;  
+        void setFullName (const QString& fullName);
+
+        QString givenName (void) const;
+        void setGivenName (const QString& givenName);
+
+        QString familyName (void) const;
+        void setFamilyName (const QString& familyName);
+
+        bool hasPhoto (void) const;
+        bool hasPhotoLink (void) const;
+        THGoogleLink *photoLink (void) const;
+
+        bool hasEditPhoto (void) const;
+        bool hasEditPhotoLink (void) const;
+        THGoogleLink *editPhotoLink (void) const;
+
+        QList<THGoogleIm *> imAddresses (void) const;
+        QList<THGoogleEmail *> emailAddresses (void) const;
+        QList<THGooglePhoneNumber *> phoneNumbers (void) const;
+        QList<THGoogleOrganization *> organizations (void) const;
+        QList<THGooglePostalAddress *> postalAddresses (void) const;
+        QList<THGoogleContactExternalId *> externalIds (void) const;
+        QList<THGoogleContactUserField> userDefinedFields (void) const;
+        QList<THGoogleGroupMembershipInfo *> groupMembershipInfos (void) const;
+
+        bool hasImAddresses (void) const;
+        bool hasPhoneNumbers (void) const;
+        bool hasOrganizations (void) const;
+        bool hasEmailAddresses (void) const;
+        bool hasPostalAddresses (void) const;
+        bool hasGroupMembershipInfos (void) const;
+
+    public:
+        static QString relPhoto (void);
+        static QString relEditPhoto (void);
+
+    public:
+        bool readXmlElement (QXmlStreamReader *xmlReader);
+        void writeXmlElement (QXmlStreamWriter *xmlWriter) const;
+
+    private:
+        THGoogleContactPrivate *d;
+};
+
+class THGoogleContactService;
+class THGoogleContactsServicePrivate;
+class THGoogleContactsService : public THGooglEntryService {
+    Q_OBJECT
+
+    friend class THGoogleContactService;
+
+    public:
+        THGoogleContactsService (QObject *parent = 0);
+        ~THGoogleContactsService();
+
+        // Methods
+        void insertContact (THGoogleContact *contact);
+        void updateContact (THGoogleContact *contact);
+        void deleteContact (THGoogleContact *contact);
+        void refreshContact (THGoogleContact *contact);
+        void refreshContact (THGoogleContact *contact, const QUrl& url);
+
+        void addContactPhoto (THGoogleContact *contact, 
+                              const QImage& image);
+        void addContactPhoto (THGoogleContact *contact, 
+                              const QPixmap& pixmap);
+        void addContactPhoto (THGoogleContact *contact, 
+                              const QByteArray& pngData);
+
+        void addContactEditPhoto (THGoogleContact *contact, 
+                                  const QImage& image);
+        void addContactEditPhoto (THGoogleContact *contact, 
+                                  const QPixmap& pixmap);
+        void addContactEditPhoto (THGoogleContact *contact, 
+                                  const QByteArray& pngData);
+
+        void insertGroup (THGoogleContactGroup *group);
+        void updateGroup (THGoogleContactGroup *group);
+        void deleteGroup (THGoogleContactGroup *group);
+        void refreshGroup (THGoogleContactGroup *group);
+        void refreshGroup (THGoogleContactGroup *group, const QUrl& url);
+
+        void retrieveAllContacts (void);
+        void retrieveAllGroups (void);
+
+        QList<THGoogleContact *> contactList (void) const;
+        QList<THGoogleContactGroup *> groupList (void) const;
+
+    protected:
+        void parseResponse (QNetworkReply *reply);
+
+    protected:
+        void setContactList (const QList<THGoogleContact *>& contacts);
+        void setGroupList (const QList<THGoogleContactGroup *>& groups);
+
+    private:
+        THGoogleContactsServicePrivate *d;
+};
+
+#endif /* !_GOOGLECONTACTS_H_ */
+
diff --git a/Google/src/googledetectlanguage.cpp b/Google/src/googledetectlanguage.cpp
index 0a00bc4..0c321c1 100644
--- a/Google/src/googledetectlanguage.cpp
+++ b/Google/src/googledetectlanguage.cpp
@@ -81,10 +81,10 @@ void THGoogleDetectLanguage::detectLanguage (const QString& query) {
     url.addQueryItem("q", query);
     url.addQueryItem("v", "1.0");
 
-    if (!hostLanguage().isEmpty())
+    if (hasHostLanguage())
         url.addQueryItem("hl", hostLanguage());
 
-    if (!apiKey().isEmpty())
+    if (hasApiKey())
         url.addQueryItem("key", apiKey());
 
     get(url);
diff --git a/Google/src/googleentry.cpp b/Google/src/googleentry.cpp
new file mode 100644
index 0000000..3cfd21b
--- /dev/null
+++ b/Google/src/googleentry.cpp
@@ -0,0 +1,917 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <QXmlStreamReader>
+#include <QXmlStreamWriter>
+#include <QNetworkRequest>
+
+#include "googleentry.h"
+
+// ===========================================================================
+//  Abstract Content
+// ===========================================================================
+class THGoogleContentPrivate {
+    public:
+        QString content;
+        QString type;
+        QString lang;
+};
+
+THGoogleContent::THGoogleContent (QObject *parent)
+    : QObject(parent), d(new THGoogleContentPrivate)
+{
+}
+
+THGoogleContent::~THGoogleContent() {
+    delete d;
+}
+
+void THGoogleContent::readXml (QXmlStreamReader *xmlReader) {
+    if (xmlReader->attributes().hasAttribute("type"))
+        d->type = xmlReader->attributes().value("type").toString().simplified();
+
+    // TODO: Handle Language
+
+    QString contentTag = xmlReader->name().toString();
+    while (!xmlReader->atEnd()) {
+        xmlReader->readNext();
+
+        QStringRef name = xmlReader->name();
+        if (xmlReader->isEndElement() && name == contentTag)
+            break;
+
+        // TODO: READ ALL DATA
+    }
+}
+
+void THGoogleContent::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->type.isEmpty())
+        xmlWriter->writeAttribute("type", d->type);
+
+    // TODO: Handle Language
+
+    xmlWriter->writeCharacters(d->content);
+}
+
+bool THGoogleContent::isEmpty (void) const {
+    return(d->content.isEmpty());
+}
+
+QString THGoogleContent::lang (void) const {
+    return(d->lang);
+}
+
+void THGoogleContent::setLang (const QString& lang) {
+    d->lang = lang;
+}
+
+QString THGoogleContent::type (void) const {
+    return(d->type);
+}
+
+void THGoogleContent::setType (const QString& type) {
+    d->type = type;
+}
+
+QString THGoogleContent::content (void) const {
+    return(d->content);
+}
+
+void THGoogleContent::setContent (const QString& content, const QString& type) {
+    d->content = content;
+    d->type = type;
+}
+
+void THGoogleContent::setHtml (const QString& html) {
+    d->content = html;
+    d->type = "text/html";
+}
+
+void THGoogleContent::setPlainText (const QString& text) {
+    d->content = text;
+    d->type = "text";
+}
+
+// ===========================================================================
+//  Link
+// ===========================================================================
+class THGoogleLinkPrivate {
+    public:
+        QString titleLang;
+        QString hrefLang;
+        quint32 length;
+        QString title;
+        QString href;
+        QString type;
+        QString etag;
+        QString rel;
+};
+
+THGoogleLink::THGoogleLink (QObject *parent)
+    : QObject(parent), d(new THGoogleLinkPrivate)
+{
+    d->length = 0;
+}
+
+THGoogleLink::~THGoogleLink() {
+    delete d;
+}
+
+void THGoogleLink::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    if (attributes.hasAttribute("type"))
+        d->type = attributes.value("type").toString().simplified();
+
+    if (attributes.hasAttribute("href"))
+        d->href = attributes.value("href").toString().simplified();
+}
+
+void THGoogleLink::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    if (!d->type.isEmpty())
+        xmlWriter->writeAttribute("type", d->type);
+
+    if (!d->href.isEmpty())
+        xmlWriter->writeAttribute("href", d->href);
+}
+
+bool THGoogleLink::hasRel (void) const {
+    return(!d->rel.isEmpty());
+}
+
+QString THGoogleLink::rel (void) const {
+    return(d->rel);
+}
+
+void THGoogleLink::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+bool THGoogleLink::hasType (void) const {
+    return(!d->type.isEmpty());
+}
+
+QString THGoogleLink::type (void) const {
+    return(d->type);
+}
+
+void THGoogleLink::setType (const QString& type) {
+    d->type = type;
+}
+
+bool THGoogleLink::hasHref (void) const {
+    return(!d->href.isEmpty());
+}
+
+QString THGoogleLink::href (void) const {
+    return(d->href);
+}
+
+void THGoogleLink::setHref (const QString& href) {
+    d->href = href;
+}
+
+bool THGoogleLink::hasHrefLang (void) const {
+    return(!d->hrefLang.isEmpty());
+}
+
+QString THGoogleLink::hrefLang (void) const {
+    return(d->hrefLang);
+}
+
+void THGoogleLink::setHrefLang (const QString& hrefLang) {
+    d->hrefLang = hrefLang;
+}
+
+quint32 THGoogleLink::length (void) const {
+    return(d->length);
+}
+
+void THGoogleLink::setLength (quint32 length) {
+    d->length = length;
+}
+
+bool THGoogleLink::hasEtag (void) const {
+    return(!d->etag.isEmpty());
+}
+
+QString THGoogleLink::etag (void) const {
+    return(d->etag);
+}
+
+void THGoogleLink::setEtag (const QString& etag) {
+    d->etag = etag;
+}
+
+QString THGoogleLink::title (void) const {
+    return(d->title);
+}
+
+void THGoogleLink::setTitle (const QString& title) {
+    d->title = title;
+}
+
+QString THGoogleLink::titleLang (void) const {
+    return(d->titleLang);
+}
+
+void THGoogleLink::setTitleLang (const QString& titleLang) {
+    d->titleLang = titleLang;
+}
+
+// ===========================================================================
+//  RelValue Info
+// ===========================================================================
+class THGoogleRelValueInfoPrivate {
+    public:
+        QString label;
+        QString value;
+        QString rel;
+};
+
+THGoogleRelValueInfo::THGoogleRelValueInfo (QObject *parent)
+    : QObject(parent), d(new THGoogleRelValueInfoPrivate)
+{
+}
+
+THGoogleRelValueInfo::~THGoogleRelValueInfo() {
+    delete d;
+}
+
+void THGoogleRelValueInfo::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("label"))
+        d->label = attributes.value("label").toString().simplified();
+
+    if (attributes.hasAttribute("rel"))
+        d->rel = attributes.value("rel").toString().simplified();
+
+    if (attributes.hasAttribute("value"))
+        d->value = attributes.value("value").toString().simplified();
+}
+
+void THGoogleRelValueInfo::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->label.isEmpty())
+        xmlWriter->writeAttribute("label", d->label);
+
+    if (!d->rel.isEmpty())
+        xmlWriter->writeAttribute("rel", d->rel);
+
+    xmlWriter->writeAttribute("value", d->value);
+}
+
+bool THGoogleRelValueInfo::hasRel (void) const {
+    return(!d->rel.isEmpty());
+}
+
+QString THGoogleRelValueInfo::rel (void) const {
+    return(d->rel);
+}
+
+void THGoogleRelValueInfo::setRel (const QString& rel) {
+    d->rel = rel;
+}
+
+QString THGoogleRelValueInfo::value (void) const {
+    return(d->value);
+}
+
+void THGoogleRelValueInfo::setValue (const QString& value) {
+    d->value = value;
+}
+
+bool THGoogleRelValueInfo::hasLabel (void) const {
+    return(!d->label.isEmpty());
+}
+
+QString THGoogleRelValueInfo::label (void) const {
+    return(d->label);
+}
+
+void THGoogleRelValueInfo::setLabel (const QString& label) {
+    d->label = label;
+}
+
+// ===========================================================================
+//  Category
+// ===========================================================================
+class THGoogleCategoryPrivate {
+    public:
+        QString scheme;
+        QString label;
+        QString term;
+};
+
+THGoogleCategory::THGoogleCategory (QObject *parent)
+    : QObject(parent), d(new THGoogleCategoryPrivate)
+{
+}
+
+THGoogleCategory::~THGoogleCategory() {
+    delete d;
+}
+
+void THGoogleCategory::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+
+    if (attributes.hasAttribute("term"))
+        d->term = attributes.value("term").toString().simplified();
+
+    if (attributes.hasAttribute("scheme"))
+        d->scheme = attributes.value("scheme").toString().simplified();
+}
+
+void THGoogleCategory::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->term.isEmpty())
+        xmlWriter->writeAttribute("term", d->term);
+
+    if (!d->scheme.isEmpty())
+        xmlWriter->writeAttribute("scheme", d->scheme);
+}
+
+bool THGoogleCategory::hasLabel (void) const {
+    return(!d->label.isEmpty());
+}
+
+QString THGoogleCategory::label (void) const {
+    return(d->label);
+}
+
+void THGoogleCategory::setLabel (const QString& label) {
+    d->label = label;
+}
+
+QString THGoogleCategory::term (void) const {
+    return(d->term);
+}
+
+void THGoogleCategory::setTerm (const QString& term) {
+    d->term = term;
+}
+
+QString THGoogleCategory::scheme (void) const {
+    return(d->scheme);
+}
+
+void THGoogleCategory::setScheme (const QString& scheme) {
+    d->scheme = scheme;
+}
+
+// ===========================================================================
+//  Person
+// ===========================================================================
+class THGooglePersonPrivate {
+    public:
+        QString email;
+        QString name;
+        QString uri;
+};
+
+THGooglePerson::THGooglePerson (QObject *parent)
+    : QObject(parent), d(new THGooglePersonPrivate)
+{
+}
+
+THGooglePerson::~THGooglePerson() {
+    delete d;
+}
+
+void THGooglePerson::readXml (QXmlStreamReader *xmlReader) {
+    // TODO: Handle URI
+    QString personTag = xmlReader->name().toString();
+    while (!xmlReader->atEnd()) {
+        xmlReader->readNext();
+
+        if (xmlReader->isEndElement() && xmlReader->name() == personTag)
+            break;
+
+        if (!xmlReader->isStartElement())
+            break;
+
+        QStringRef name = xmlReader->name();
+        if (name == "name")
+            d->name = xmlReader->readElementText().simplified();
+        else if (name == "email")
+            d->email = xmlReader->readElementText().simplified();
+    }
+}
+
+void THGooglePerson::writeXml (QXmlStreamWriter *xmlWriter) {
+    // TODO: Handle URI
+    xmlWriter->writeTextElement("name", d->name);
+    xmlWriter->writeTextElement("email", d->email);
+}
+
+QString THGooglePerson::uri (void) const {
+    return(d->uri);
+}
+
+void THGooglePerson::setUri (const QString& uri) {
+    d->uri = uri;
+}
+
+QString THGooglePerson::name (void) const {
+    return(d->name);
+}
+
+void THGooglePerson::setName (const QString& name) {
+    d->name = name;
+}
+
+QString THGooglePerson::email (void) const {
+    return(d->email);
+}
+
+void THGooglePerson::setEmail (const QString& email) {
+    d->email = email;
+}
+
+
+// ===========================================================================
+//  Extended Property
+// ===========================================================================
+class THGoogleExtendedPropertyPrivate {
+    public:
+        QString value;
+        QString realm;
+        QString name;
+};
+
+THGoogleExtendedProperty::THGoogleExtendedProperty (QObject *parent)
+    : QObject(parent), d(new THGoogleExtendedPropertyPrivate)
+{
+}
+
+THGoogleExtendedProperty::~THGoogleExtendedProperty() {
+    delete d;
+}
+
+void THGoogleExtendedProperty::readXml (QXmlStreamReader *xmlReader) {
+    QXmlStreamAttributes attributes = xmlReader->attributes();
+    if (attributes.hasAttribute("name"))
+        d->name = attributes.value("name").toString().simplified();
+
+    if (attributes.hasAttribute("value"))
+        d->value = attributes.value("value").toString().simplified();
+    else
+        d->value = xmlReader->readElementText().simplified();
+}
+
+void THGoogleExtendedProperty::writeXml (QXmlStreamWriter *xmlWriter) {
+    if (!d->name.isEmpty())
+        xmlWriter->writeAttribute("name", d->name);
+
+    if (!d->value.isEmpty())
+        xmlWriter->writeAttribute("value", d->value);
+}
+
+QString THGoogleExtendedProperty::name (void) const {
+    return(d->name);
+}
+
+void THGoogleExtendedProperty::setName (const QString& name) {
+    d->name = name;
+}
+
+
+bool THGoogleExtendedProperty::hasRealm (void) const {
+    return(!d->realm.isEmpty());
+}
+
+QString THGoogleExtendedProperty::realm (void) const {
+    return(d->realm);
+}
+
+void THGoogleExtendedProperty::setRealm (const QString& realm) {
+    d->realm = realm;
+}
+
+
+bool THGoogleExtendedProperty::hasValue (void) const {
+    return(!d->value.isEmpty());
+}
+
+QString THGoogleExtendedProperty::value (void) const {
+    return(d->value);
+}
+
+void THGoogleExtendedProperty::setValue (const QString& value) {
+    d->value = value;
+}
+
+// ===========================================================================
+//  Entry
+// ===========================================================================
+class THGoogleEntryPrivate {
+    public:
+        QList<THGoogleEntryAdapter *> adapters;
+        
+        QList<THGoogleExtendedProperty *> extendedProperties;
+        QList<THGoogleLink *> links;
+        THGoogleCategory category;
+        THGoogleContent content;
+        THGoogleContent summary;
+        THGooglePerson author;
+        QDateTime published;
+        QDateTime updated;
+        bool isDeleted;
+        QString title;
+        QString etag;
+        QString id;
+};
+
+THGoogleEntry::THGoogleEntry (QObject *parent)
+    : QObject(parent), d(new THGoogleEntryPrivate)
+{
+    d->isDeleted = false;
+}
+
+THGoogleEntry::~THGoogleEntry() {
+    delete d;
+}
+
+void THGoogleEntry::clear (void) {
+    d->extendedProperties.clear();
+    d->isDeleted = false;
+    d->links.clear();
+    d->title.clear();
+    d->etag.clear();
+    d->id.clear();
+}
+
+void THGoogleEntry::readXml (QXmlStreamReader *xmlReader) {
+    if (xmlReader->attributes().hasAttribute("gd:etag"))
+        d->etag = xmlReader->attributes().value("gd:etag").toString().simplified();
+
+    while (!xmlReader->atEnd()) {
+        xmlReader->readNext();
+
+        QStringRef name = xmlReader->name();
+        if (xmlReader->isEndElement() && name == "entry")
+            break;
+
+        if (!xmlReader->isStartElement())
+            continue;
+
+        QStringRef qualifiedName = xmlReader->qualifiedName();
+        if (name == "link") {
+            THGoogleLink *link = new THGoogleLink;
+            link->readXml(xmlReader);
+            d->links.append(link);
+        } else if (name == "id") {
+            d->id = xmlReader->readElementText().simplified();
+        } else if (name == "title") {
+            d->title = xmlReader->readElementText().simplified();
+        } else if (name == "summary") {
+            d->summary.readXml(xmlReader);
+        } else if (name == "content") {
+            d->content.readXml(xmlReader);
+        } else if (name == "author") {
+            d->author.readXml(xmlReader);
+        } else if (name == "published") {
+            QString dateString = xmlReader->readElementText().simplified();
+            d->published = QDateTime::fromString(dateString, Qt::ISODate);
+        } else if (name == "updated") {
+            QString dateString = xmlReader->readElementText().simplified();
+            d->updated = QDateTime::fromString(dateString, Qt::ISODate);
+        } else if (name == "category") {
+            d->category.readXml(xmlReader);
+        } else if (qualifiedName == "gd:extendedProperty") {
+            THGoogleExtendedProperty *extProperty = new THGoogleExtendedProperty(this);
+            extProperty->readXml(xmlReader);
+            d->extendedProperties.append(extProperty);
+        } else if (qualifiedName == "gd:deleted") {
+            d->isDeleted = true;
+        } else {
+            foreach (THGoogleEntryAdapter *adapter, d->adapters) {
+                if (adapter->readXmlElement(xmlReader))
+                    break;
+            }
+        }
+    }
+}
+
+void THGoogleEntry::writeXml (QXmlStreamWriter *xmlWriter) const {
+    // Entry
+    xmlWriter->writeStartElement("entry");
+    xmlWriter->writeAttribute("xmlns", "http://www.w3.org/2005/Atom");
+    xmlWriter->writeAttribute("xmlns:gd", "http://schemas.google.com/g/2005");
+    xmlWriter->writeAttribute("xmlns:openSearch", "http://a9.com/-/spec/opensearch/1.1/");
+    xmlWriter->writeAttribute("xmlns:gContact", "http://schemas.google.com/contact/2008");
+    xmlWriter->writeAttribute("xmlns:batch", "http://schemas.google.com/gdata/batch");
+
+    if (!d->etag.isEmpty())
+        xmlWriter->writeAttribute("gd:etag", d->etag);
+
+    // Id
+    if (!d->id.isEmpty())
+        xmlWriter->writeTextElement("id", d->id);
+
+    if (!d->updated.isNull())
+        xmlWriter->writeTextElement("updated", d->updated.toString(Qt::ISODate));
+
+    // Category
+    xmlWriter->writeEmptyElement("category");
+    d->category.writeXml(xmlWriter);
+
+    // Title
+    if (!d->title.isEmpty())
+        xmlWriter->writeTextElement("title", d->title);
+
+    // Content
+    if (!d->content.isEmpty()) {
+        xmlWriter->writeStartElement("content");
+        d->content.writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    // Summary
+    if (!d->summary.isEmpty()) {
+        xmlWriter->writeStartElement("summary");
+        d->summary.writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    // Extended Properties
+    foreach (THGoogleExtendedProperty *extProperty, d->extendedProperties) {
+        xmlWriter->writeStartElement("gd:extendedProperty");
+        extProperty->writeXml(xmlWriter);
+        xmlWriter->writeEndElement();
+    }
+
+    foreach (THGoogleEntryAdapter *adapter, d->adapters)
+        adapter->writeXmlElement(xmlWriter);
+
+    if (d->isDeleted)
+        xmlWriter->writeEmptyElement("gd:deleted");
+
+    xmlWriter->writeEndElement();
+}
+
+
+void THGoogleEntry::addAdapter (THGoogleEntryAdapter *adapter) {
+    d->adapters.append(adapter);
+}
+
+void THGoogleEntry::addLink (THGoogleLink *link) {
+    d->links.append(link);
+}
+
+void THGoogleEntry::addLink (const QString& rel,
+                             const QString& type,
+                             const QString& href)
+{
+    THGoogleLink *link = new THGoogleLink(this);
+    link->setRel(rel);
+    link->setType(type);
+    link->setHref(href);
+    d->links.append(link);
+}
+
+void THGoogleEntry::addExtendedProperty (THGoogleExtendedProperty *property) {
+    property->setParent(this);
+    d->extendedProperties.append(property);
+}
+
+QString THGoogleEntry::id (void) const {
+    return(d->id);
+}
+
+void THGoogleEntry::setId (const QString& id) {
+    d->id = id;
+}
+
+QString THGoogleEntry::etag (void) const {
+    return(d->etag);
+}
+
+void THGoogleEntry::setEtag (const QString& etag) {
+    d->etag = etag;
+}
+
+QString THGoogleEntry::title (void) const {
+    return(d->title);
+}
+
+void THGoogleEntry::setTitle (const QString& title) {
+    d->title = title;
+}
+
+
+bool THGoogleEntry::isDeleted (void) const {
+    return(d->isDeleted);
+}
+
+void THGoogleEntry::setDeleted (bool deleted) {
+    d->isDeleted = deleted;
+}
+
+QDateTime THGoogleEntry::updated (void) const {
+    return(d->updated);
+}
+
+QDateTime THGoogleEntry::published (void) const {
+    return(d->published);
+}
+
+THGooglePerson *THGoogleEntry::author (void) const {
+    return(&(d->author));
+}
+
+THGoogleContent *THGoogleEntry::summary (void) const {
+    return(&(d->summary));
+}
+
+THGoogleContent *THGoogleEntry::content (void) const {
+    return(&(d->content));
+}
+
+THGoogleCategory *THGoogleEntry::category (void) const {
+    return(&(d->category));
+}
+
+THGoogleLink *THGoogleEntry::link (const QString& rel, 
+                                   const QString& type) const
+{
+    QList<THGoogleLink *> results;
+    foreach (THGoogleLink *link, d->links) {
+        if (link->rel() == rel && link->type() == type)
+            return(link);
+    }
+
+    return(NULL);
+}
+
+QList<THGoogleLink *> THGoogleEntry::links (void) const {
+    return(d->links);
+}
+
+QList<THGoogleLink *> THGoogleEntry::links (const QString& rel, 
+                                            const QString& type) const
+{
+    QList<THGoogleLink *> results;
+    foreach (THGoogleLink *link, d->links) {
+        if (link->rel() == rel && link->type() == type)
+            results.append(link);
+    }
+    return(results);
+}
+
+bool THGoogleEntry::hasExtendedProperties (void) const {
+    return(!d->extendedProperties.isEmpty());
+}
+
+QList<THGoogleExtendedProperty *> THGoogleEntry::extendedProperties (void) const {
+    return(d->extendedProperties);
+}
+
+QByteArray THGoogleEntry::toXml (void) const {
+    QByteArray xml;
+    QXmlStreamWriter xmlWriter(&xml);
+    xmlWriter.setAutoFormatting(true);
+    writeXml(&xmlWriter);
+    return(xml.trimmed());
+}
+
+// ===========================================================================
+//  Entry Service
+// ===========================================================================
+class THGoogleEntryServicePrivate {
+    public:
+        QString gdataVersion;
+        QString authToken;
+
+    public:
+        QByteArray authHeaderValue (void) const;
+        QByteArray dataVersionHeaderValue (void) const;
+};
+
+QByteArray THGoogleEntryServicePrivate::authHeaderValue (void) const {
+    return(QString("GoogleLogin auth=%1").arg(authToken).toLatin1());
+}
+
+QByteArray THGoogleEntryServicePrivate::dataVersionHeaderValue (void) const {
+    return(gdataVersion.toLatin1());
+}
+
+// ===========================================================================
+//  PUBLIC Constructors/Destructors
+// ===========================================================================
+THGooglEntryService::THGooglEntryService (QObject *parent)
+    : THGoogleService(parent), d(new THGoogleEntryServicePrivate)
+{
+    d->gdataVersion = "2";
+}
+
+THGooglEntryService::~THGooglEntryService() {
+    delete d;
+}
+
+// ===========================================================================
+//  PUBLIC Properties
+// ===========================================================================
+QString THGooglEntryService::authToken (void) const {
+    return(d->authToken);
+}
+
+void THGooglEntryService::setAuthToken (const QString& authToken) {
+    d->authToken = authToken;
+}
+
+QString THGooglEntryService::gdataVersion (void) const {
+    return(d->gdataVersion);
+}
+
+void THGooglEntryService::setGDataVersion (const QString& gdataVersion) {
+    d->gdataVersion = gdataVersion;
+}
+
+// ===========================================================================
+//  PROTECTED Methods
+// ===========================================================================
+QNetworkReply *THGooglEntryService::queryEntry (const QUrl& url) {
+    QNetworkRequest request(url);
+    request.setRawHeader("Authorization", d->authHeaderValue());
+    request.setRawHeader("GData-Version", d->dataVersionHeaderValue());
+    request.setHeader(QNetworkRequest::ContentTypeHeader, 
+                      "application/x-www-form-urlencoded");
+
+    return(get(request));
+}
+
+QNetworkReply *THGooglEntryService::insertEntry (const QUrl& url,
+                                                 const QByteArray& xml)
+{
+    QNetworkRequest request(url);
+    request.setRawHeader("Authorization", d->authHeaderValue());
+    request.setRawHeader("GData-Version", d->dataVersionHeaderValue());
+    request.setHeader(QNetworkRequest::ContentTypeHeader, 
+                      "application/atom+xml");
+
+    return(post(request, xml));
+}
+
+QNetworkReply *THGooglEntryService::updateEntry (const QUrl& url, 
+                                                 const QByteArray& etag,
+                                                 const QByteArray& xml)
+{
+    QNetworkRequest request(url);
+    request.setRawHeader("X-HTTP-Method-Override", "PUT");
+    request.setRawHeader("Authorization", d->authHeaderValue());
+    request.setRawHeader("GData-Version", d->dataVersionHeaderValue());
+    request.setRawHeader("If-Match", etag);
+    request.setHeader(QNetworkRequest::ContentTypeHeader, 
+                      "application/atom+xml");
+
+    return(post(request, xml));
+}
+
+QNetworkReply *THGooglEntryService::updateEntry (const QNetworkRequest& req,
+                                                 const QByteArray& data)
+{
+    QNetworkRequest request(req);
+    request.setRawHeader("X-HTTP-Method-Override", "PUT");
+    request.setRawHeader("Authorization", d->authHeaderValue());
+    request.setRawHeader("GData-Version", d->dataVersionHeaderValue());
+
+    return(post(request, data));
+}
+
+QNetworkReply *THGooglEntryService::deleteEntry (const QUrl& url, 
+                                                 const QByteArray& etag,
+                                                 const QByteArray& xml)
+{
+    QNetworkRequest request(url);
+    request.setRawHeader("X-HTTP-Method-Override", "DELETE");
+    request.setRawHeader("Authorization", d->authHeaderValue());
+    request.setRawHeader("GData-Version", d->dataVersionHeaderValue());
+    request.setRawHeader("If-Match", etag);
+    request.setHeader(QNetworkRequest::ContentTypeHeader, 
+                      "application/atom+xml");
+
+    return(post(request, xml));
+}
+
diff --git a/Google/src/googleentry.h b/Google/src/googleentry.h
new file mode 100644
index 0000000..96ccf49
--- /dev/null
+++ b/Google/src/googleentry.h
@@ -0,0 +1,311 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _GOOGLEENTRY_H_
+#define _GOOGLEENTRY_H_
+
+#include <QDateTime>
+#include <QObject>
+class QXmlStreamReader;
+class QXmlStreamWriter;
+
+class THGoogleContentPrivate;
+class THGoogleContent : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleContent (QObject *parent = 0);
+        virtual ~THGoogleContent();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool isEmpty (void) const;
+
+        QString lang (void) const;
+        void setLang (const QString& lang);
+
+        QString type (void) const;
+        void setType (const QString& type);
+
+        QString content (void) const;
+        void setContent (const QString& content, const QString& type);
+
+        void setHtml (const QString& html);
+        void setPlainText (const QString& text);
+
+    private:
+        THGoogleContentPrivate *d;
+};
+
+class THGoogleLinkPrivate;
+class THGoogleLink : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleLink (QObject *parent = 0);
+        ~THGoogleLink();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool hasRel (void) const;
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+        bool hasType (void) const;
+        QString type (void) const;
+        void setType (const QString& type);
+
+        bool hasHref (void) const;
+        QString href (void) const;
+        void setHref (const QString& href);
+
+        bool hasHrefLang (void) const;
+        QString hrefLang (void) const;
+        void setHrefLang (const QString& hrefLang);
+
+        quint32 length (void) const;
+        void setLength (quint32 length);
+
+        bool hasEtag (void) const;
+        QString etag (void) const;
+        void setEtag (const QString& etag);
+
+        QString title (void) const;
+        void setTitle (const QString& title);
+
+        QString titleLang (void) const;
+        void setTitleLang (const QString& titleLang);    
+
+    private:
+        THGoogleLinkPrivate *d;
+};
+
+class THGoogleRelValueInfoPrivate;
+class THGoogleRelValueInfo : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleRelValueInfo (QObject *parent = 0);
+        ~THGoogleRelValueInfo();
+
+        // Methods
+        virtual void readXml (QXmlStreamReader *xmlReader);
+        virtual void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool hasRel (void) const;
+        QString rel (void) const;
+        void setRel (const QString& rel);
+
+        QString value (void) const;
+        void setValue (const QString& value);
+
+        bool hasLabel (void) const;
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+    private:
+        THGoogleRelValueInfoPrivate *d;
+};
+
+class THGoogleCategoryPrivate;
+class THGoogleCategory : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleCategory (QObject *parent = 0);
+        ~THGoogleCategory();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        bool hasLabel (void) const;
+        QString label (void) const;
+        void setLabel (const QString& label);
+
+        QString term (void) const;
+        void setTerm (const QString& term);
+
+        QString scheme (void) const;
+        void setScheme (const QString& scheme);
+
+    private:
+        THGoogleCategoryPrivate *d;
+};
+
+class THGooglePersonPrivate;
+class THGooglePerson : public QObject {
+    Q_OBJECT
+
+    public:
+        THGooglePerson (QObject *parent = 0);
+        ~THGooglePerson();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        QString uri (void) const;
+        void setUri (const QString& uri);
+
+        QString name (void) const;
+        void setName (const QString& name);
+
+        QString email (void) const;
+        void setEmail (const QString& email);
+
+    private:
+        THGooglePersonPrivate *d;
+};
+
+class THGoogleExtendedPropertyPrivate;
+class THGoogleExtendedProperty : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleExtendedProperty (QObject *parent = 0);
+        ~THGoogleExtendedProperty();
+
+        // Methods
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter);
+
+        // Properties
+        QString name (void) const;
+        void setName (const QString& name);
+
+        bool hasRealm (void) const;
+        QString realm (void) const;
+        void setRealm (const QString& realm);
+
+        bool hasValue (void) const;
+        QString value (void) const;
+        void setValue (const QString& value);
+
+    private:
+        THGoogleExtendedPropertyPrivate *d;
+};
+
+class THGoogleEntryAdapter {
+    public:
+        virtual bool readXmlElement (QXmlStreamReader *xmlReader) = 0;
+        virtual void writeXmlElement (QXmlStreamWriter *xmlWriter) const = 0;
+};
+
+class THGoogleEntryPrivate;
+class THGoogleEntry : public QObject {
+    Q_OBJECT
+
+    public:
+        THGoogleEntry (QObject *parent = 0);
+        ~THGoogleEntry();
+
+        // Methods      
+        void readXml (QXmlStreamReader *xmlReader);
+        void writeXml (QXmlStreamWriter *xmlWriter) const;
+
+        virtual void clear (void);
+
+        // Properties
+        void addAdapter (THGoogleEntryAdapter *adaptor);
+        void addExtendedProperty (THGoogleExtendedProperty *property);
+
+        void addLink (THGoogleLink *link);
+        void addLink (const QString& rel,
+                      const QString& type,
+                      const QString& href);
+
+        QString id (void) const;
+        void setId (const QString& id);
+
+        QString etag (void) const;
+        void setEtag (const QString& etag);
+
+        QString title (void) const;
+        void setTitle (const QString& title);
+
+        bool isDeleted (void) const;
+        void setDeleted (bool deleted);
+
+        QDateTime updated (void) const;
+        QDateTime published (void) const;
+
+        THGooglePerson *author (void) const;
+        THGoogleContent *summary (void) const;
+        THGoogleContent *content (void) const;
+        THGoogleCategory *category (void) const;
+
+        THGoogleLink *link (const QString& rel, const QString& type) const;
+
+        QList<THGoogleLink *> links (void) const;
+        QList<THGoogleLink *> links (const QString& rel, const QString& type) const;
+
+        bool hasExtendedProperties (void) const;
+        QList<THGoogleExtendedProperty *> extendedProperties (void) const;
+
+        QByteArray toXml (void) const;
+
+    private:
+        THGoogleEntryPrivate *d;
+};
+
+#include "googleservice.h"
+class THGoogleEntryServicePrivate;
+
+class THGooglEntryService : public THGoogleService {
+    Q_OBJECT
+
+    public:
+        THGooglEntryService (QObject *parent = 0);
+        ~THGooglEntryService();
+
+        QString authToken (void) const;
+        void setAuthToken (const QString& authToken);
+
+        QString gdataVersion (void) const;
+        void setGDataVersion (const QString& gDataVersion);
+
+    protected:
+        QNetworkReply *queryEntry (const QUrl& url);
+        QNetworkReply *insertEntry (const QUrl& url, const QByteArray& xml);
+        QNetworkReply *updateEntry (const QUrl& url,
+                                    const QByteArray& etag, 
+                                    const QByteArray& xml);
+        QNetworkReply *deleteEntry (const QUrl& url, 
+                                    const QByteArray& etag,
+                                    const QByteArray& xml);
+
+        QNetworkReply *updateEntry (const QNetworkRequest& req,
+                                    const QByteArray& data);
+
+    private:
+        THGoogleEntryServicePrivate *d;
+};
+
+#endif /* !_GOOGLEENTRY_H_ */
+
diff --git a/Google/src/googlegeocoding.cpp b/Google/src/googlegeocoding.cpp
new file mode 100644
index 0000000..27b5881
--- /dev/null
+++ b/Google/src/googlegeocoding.cpp
@@ -0,0 +1,274 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <QNetworkAccessManager>
+#include <QXmlStreamReader>
+#include <QNetworkReply>
+#include <QStringList>
+#include <QDebug>
+
+#include "googlegeocoding.h"
+
+// ===========================================================================
+//  GEOPlacemark
+// ===========================================================================
+#define GEO_LATLONG_BOX_NORTH       0
+#define GEO_LATLONG_BOX_SOUTH       1
+#define GEO_LATLONG_BOX_EAST        2
+#define GEO_LATLONG_BOX_WEST        3
+
+class THGoogleGeoPlacemarkPrivate {
+    public:
+        QString subAdministrativeAreaName;
+        QString administrativeAreaName;
+        QString thoroughfareName;
+        QString postalCodeNumber;
+        QString localityName;
+        QString countryCode;
+        QString countryName;
+        QPointF coordinates;
+        qreal latLongBox[4];
+        QString address;
+
+    public:
+        void parsePlacemark (QXmlStreamReader *xmlReader);
+};
+
+void THGoogleGeoPlacemarkPrivate::parsePlacemark (QXmlStreamReader *xmlReader) {
+    if (xmlReader->name() == "address") {
+        address = xmlReader->readElementText();
+    } else if (xmlReader->name() == "ContryNameCode") {
+        countryCode = xmlReader->readElementText();
+    } else if (xmlReader->name() == "ContryName") {
+        countryName = xmlReader->readElementText();
+    } else if (xmlReader->name() == "AdministrativeAreaName") {
+        administrativeAreaName = xmlReader->readElementText();
+    } else if (xmlReader->name() == "SubAdministrativeAreaName") {
+        subAdministrativeAreaName = xmlReader->readElementText();
+    } else if (xmlReader->name() == "LocalityName") {
+        localityName = xmlReader->readElementText();
+    } else if (xmlReader->name() == "ThoroughfareName") {
+        thoroughfareName = xmlReader->readElementText();
+    } else if (xmlReader->name() == "PostalCodeNumber") {
+        postalCodeNumber = xmlReader->readElementText();
+    } else if (xmlReader->name() == "LatLonBox") {
+        if (xmlReader->attributes().hasAttribute("north")) {
+            QStringRef north = xmlReader->attributes().value("north");
+            latLongBox[GEO_LATLONG_BOX_NORTH] = north.toString().toDouble();
+        }
+
+        if (xmlReader->attributes().hasAttribute("south")) {
+            QStringRef south = xmlReader->attributes().value("south");
+            latLongBox[GEO_LATLONG_BOX_SOUTH] = south.toString().toDouble();
+        }
+
+        if (xmlReader->attributes().hasAttribute("west")) {
+            QStringRef west = xmlReader->attributes().value("west");
+            latLongBox[GEO_LATLONG_BOX_WEST] = west.toString().toDouble();
+        }
+
+        if (xmlReader->attributes().hasAttribute("east")) {
+            QStringRef east = xmlReader->attributes().value("east");
+            latLongBox[GEO_LATLONG_BOX_EAST] = east.toString().toDouble();
+        }
+    } else if (xmlReader->name() == "coordinates") {
+        QStringList coord = xmlReader->readElementText().split(',',
+                                                    QString::SkipEmptyParts);
+        if (coord.size() >= 2) {
+            coordinates.setX(coord[0].toDouble());
+            coordinates.setY(coord[1].toDouble());
+        }
+    }
+}
+
+THGoogleGeoPlacemark::THGoogleGeoPlacemark (QXmlStreamReader *xmlReader) 
+    : d(new THGoogleGeoPlacemarkPrivate)
+{
+    while (!xmlReader->atEnd()) {
+        xmlReader->readNext();
+
+        if (xmlReader->isEndElement() && xmlReader->name() == "Placemark")
+            break;
+
+        if (xmlReader->isStartElement())
+            d->parsePlacemark(xmlReader);
+    }
+}
+
+
+qreal THGoogleGeoPlacemark::east (void) const {
+    return(d->latLongBox[GEO_LATLONG_BOX_EAST]);
+}
+
+qreal THGoogleGeoPlacemark::west (void) const {
+    return(d->latLongBox[GEO_LATLONG_BOX_WEST]);
+}
+
+qreal THGoogleGeoPlacemark::north (void) const {
+    return(d->latLongBox[GEO_LATLONG_BOX_NORTH]);
+}
+
+qreal THGoogleGeoPlacemark::south (void) const {
+    return(d->latLongBox[GEO_LATLONG_BOX_SOUTH]);
+}
+
+QString THGoogleGeoPlacemark::address (void) const {
+    return(d->address);
+}
+
+QPointF THGoogleGeoPlacemark::coordinates (void) const {
+    return(d->coordinates);
+}
+
+QString THGoogleGeoPlacemark::countryName (void) const {
+    return(d->countryName);
+}
+
+QString THGoogleGeoPlacemark::countryCode (void) const {
+    return(d->countryCode);
+}
+
+QString THGoogleGeoPlacemark::localityName (void) const {
+    return(d->localityName);
+}
+
+QString THGoogleGeoPlacemark::postalCodeNumber (void) const {
+    return(d->postalCodeNumber);
+}
+
+QString THGoogleGeoPlacemark::thoroughfareName (void) const {
+    return(d->thoroughfareName);
+}
+
+QString THGoogleGeoPlacemark::administrativeAreaName (void) const {
+    return(d->administrativeAreaName);
+}
+
+QString THGoogleGeoPlacemark::subAdministrativeAreaName (void) const {
+    return(d->subAdministrativeAreaName);
+}
+
+// ===========================================================================
+//  GeoCoding
+// ===========================================================================
+class THGoogleGeocodingPrivate {
+    public:
+        QList<THGoogleGeoPlacemark> geoPlacemarks;
+        QString query;
+        bool sensor;
+
+    public:
+        QString statusCodeToMessage (int statusCode);
+};
+
+QString THGoogleGeocodingPrivate::statusCodeToMessage (int statusCode) {
+    switch (statusCode) {
+        case 500: return(QObject::tr("Server Error"));
+        case 601: return(QObject::tr("Missing Query"));
+        case 602: return(QObject::tr("Unknown Address"));
+        case 603: return(QObject::tr("Unavailable Address"));
+        case 610: return(QObject::tr("Bad Key"));
+        case 620: return(QObject::tr("Too Many Queries"));
+    }
+
+    return(QString());
+}
+
+THGoogleGeocoding::THGoogleGeocoding (QObject *parent)
+    : THGoogleService(parent), d(new THGoogleGeocodingPrivate)
+{
+    d->sensor = false;
+}
+
+THGoogleGeocoding::~THGoogleGeocoding() {
+    delete d;
+}
+
+QString THGoogleGeocoding::query (void) const {
+    return(d->query);
+}
+
+void THGoogleGeocoding::setQuery (const QString& query) {
+    d->query = query;
+}
+
+
+bool THGoogleGeocoding::sensor (void) const {
+    return(d->sensor);
+}
+
+void THGoogleGeocoding::setSensor (bool sensor) {
+    d->sensor = sensor;
+}
+
+QList<THGoogleGeoPlacemark> THGoogleGeocoding::placemarks (void) const {
+    return(d->geoPlacemarks);
+}
+
+void THGoogleGeocoding::request (const QString& query) {
+    if (!query.isEmpty())
+        d->query = query;
+
+    QUrl url("http://maps.google.com/maps/geo");
+    url.addQueryItem("q", d->query);
+    url.addQueryItem("sensor", d->sensor ? "true" : "false");
+    url.addQueryItem("output", "xml");
+    url.addQueryItem("oe", "utf8");
+
+    if (hasApiKey())
+        url.addQueryItem("key", apiKey());
+
+    //url.addQueryItem("ll", QString("%1,%2").arg(d->latitude).arg(d->longitude));
+    //url.addQueryItem("spn", ...
+    //url.addQueryItem("gl", ...
+
+    get(url);
+}
+
+void THGoogleGeocoding::parseResponse (const QByteArray& data) {
+    QXmlStreamReader xmlReader(data);
+    while (!xmlReader.atEnd()) {
+        xmlReader.readNext();
+
+        if (!xmlReader.isStartElement())
+            continue;
+
+        if (xmlReader.name() == "Status") {
+            while (!xmlReader.atEnd()) {
+                xmlReader.readNext();
+
+                QStringRef name = xmlReader.name();
+                if (xmlReader.isEndElement() && name == "Status")
+                    break;
+
+                if (xmlReader.isStartElement() && name == "Code") {
+                    int statusCode = xmlReader.readElementText().toInt();
+                    setResponseStatus(statusCode);
+                    setErrorString(d->statusCodeToMessage(statusCode));
+                    break;
+                }
+            }
+        } else if (xmlReader.name() == "Placemark") {
+            d->geoPlacemarks.append(THGoogleGeoPlacemark(&xmlReader));
+        }
+    }
+    qDebug() << "PARSE FINISHED";
+    emit finished(responseStatus() != 200);
+}
+
diff --git a/Google/src/googlegeocoding.h b/Google/src/googlegeocoding.h
new file mode 100644
index 0000000..b33cb62
--- /dev/null
+++ b/Google/src/googlegeocoding.h
@@ -0,0 +1,79 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _GOOGLEGEOCODING_H_
+#define _GOOGLEGEOCODING_H_
+
+#include "googleservice.h"
+
+#include <QObject>
+#include <QPointF>
+class QNetworkReply;
+class QXmlStreamReader;
+class THGoogleGeocodingPrivate;
+class THGoogleGeoPlacemarkPrivate;
+
+class THGoogleGeoPlacemark {
+    public:
+        THGoogleGeoPlacemark (QXmlStreamReader *xmlReader);
+
+        qreal east (void) const;
+        qreal west (void) const;
+        qreal north (void) const;
+        qreal south (void) const;
+        QString address (void) const;
+        QPointF coordinates (void) const;
+        QString countryName (void) const;
+        QString countryCode (void) const;
+        QString localityName (void) const;
+        QString postalCodeNumber (void) const;
+        QString thoroughfareName (void) const;
+        QString administrativeAreaName (void) const;
+        QString subAdministrativeAreaName (void) const;
+
+    private:
+        THGoogleGeoPlacemarkPrivate *d;
+};
+
+class THGoogleGeocoding : public THGoogleService {
+    Q_OBJECT
+
+    public:
+        THGoogleGeocoding (QObject *parent = 0);
+        ~THGoogleGeocoding();
+
+        QString query (void) const;
+        void setQuery (const QString& query);
+
+        bool sensor (void) const;
+        void setSensor (bool sensor);
+
+        QList<THGoogleGeoPlacemark> placemarks (void) const;
+
+    public Q_SLOTS:
+        void request (const QString& query = QString());
+
+    protected:
+        void parseResponse (const QByteArray& data);
+
+    private:
+        THGoogleGeocodingPrivate *d;
+};
+
+#endif /* !_GOOGLEGEOCODING_H_ */
+
diff --git a/Google/src/googleservice.cpp b/Google/src/googleservice.cpp
index 4e0eeec..d831a07 100644
--- a/Google/src/googleservice.cpp
+++ b/Google/src/googleservice.cpp
@@ -60,37 +60,41 @@ THGoogleService::~THGoogleService() {
 // ===========================================================================
 //  PUBLIC Methods
 // ===========================================================================
-void THGoogleService::get (const QUrl& url) {
+QNetworkReply *THGoogleService::get (const QUrl& url) {
     d->resetResponseInfo();
-    d->networkManager.get(QNetworkRequest(url));
+    return(d->networkManager.get(QNetworkRequest(url)));
 }
 
-void THGoogleService::get (const QNetworkRequest& request) {
+QNetworkReply *THGoogleService::get (const QNetworkRequest& request) {
     d->resetResponseInfo();
-    d->networkManager.get(request);
+    return(d->networkManager.get(request));
 }
 
-void THGoogleService::post (const QUrl& url, QIODevice *data) {
+QNetworkReply *THGoogleService::post (const QUrl& url, QIODevice *data) {
     d->resetResponseInfo();
-    d->networkManager.post(QNetworkRequest(url), data);
+    return(d->networkManager.post(QNetworkRequest(url), data));
 }
 
-void THGoogleService::post (const QUrl& url, const QByteArray& data) {
+QNetworkReply *THGoogleService::post (const QUrl& url, 
+                                      const QByteArray& data)
+{
     d->resetResponseInfo();
-    d->networkManager.post(QNetworkRequest(url), data);
+    return(d->networkManager.post(QNetworkRequest(url), data));
 }
 
-void THGoogleService::post (const QNetworkRequest& request, QIODevice *data) {
+QNetworkReply *THGoogleService::post (const QNetworkRequest& request, 
+                                      QIODevice *data)
+{
     d->resetResponseInfo();
-    d->networkManager.post(request, data);
+    return(d->networkManager.post(request, data));
 }
 
 
-void THGoogleService::post (const QNetworkRequest& request, 
-                            const QByteArray& data)
+QNetworkReply *THGoogleService::post (const QNetworkRequest& request, 
+                                      const QByteArray& data)
 {
     d->resetResponseInfo();
-    d->networkManager.post(request, data);
+    return(d->networkManager.post(request, data));
 }
 
 // ===========================================================================
@@ -100,10 +104,18 @@ int THGoogleService::responseStatus (void) const {
     return(d->responseStatus);
 }
 
+bool THGoogleService::responseStatusIsError (void) const {
+    return(d->responseStatus != 200 && d->responseStatus != 201);
+}
+
 QString THGoogleService::errorString (void) const {
     return(d->errorString);
 }
 
+bool THGoogleService::hasApiKey (void) const {
+    return(!d->apiKey.isEmpty());
+}
+
 QString THGoogleService::apiKey (void) const {
     return(d->apiKey);
 }
@@ -113,6 +125,10 @@ void THGoogleService::setApiKey (const QString& apiKey) {
 }
 
 
+bool THGoogleService::hasHostLanguage (void) const {
+    return(!d->hostLanguage.isEmpty());
+}
+
 QString THGoogleService::hostLanguage (void) const {
     return(d->hostLanguage);
 }
@@ -135,22 +151,30 @@ void THGoogleService::setResponseStatus (int responseStatus) {
 // ===========================================================================
 //  PROTECTED Slots
 // ===========================================================================
+#include <QDebug>
 void THGoogleService::responseReceived (QNetworkReply *reply) {
     d->responseStatus = reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
     if (reply->error()) {
         d->errorString = reply->errorString();
-        emit finished(false);
+        qDebug() << reply->readAll();
+        emit finished(true);
     } else {
-        parseResponse(reply->readAll());
+        parseResponse(reply);
     }
 }
 
 // ===========================================================================
 //  PROTECTED Methods
 // ===========================================================================
+void THGoogleService::parseResponse (QNetworkReply *reply) {
+    parseResponse(reply->readAll());
+}
+
 void THGoogleService::parseResponse (const QByteArray& data) {
     Q_UNUSED(data)
     qWarning("Parse Response of this Service is Not Implemented");
+    qWarning(data.constData());
+    emit finished(false);
 }
 
 
diff --git a/Google/src/googleservice.h b/Google/src/googleservice.h
index 96bacd8..719e0af 100644
--- a/Google/src/googleservice.h
+++ b/Google/src/googleservice.h
@@ -35,22 +35,26 @@ class THGoogleService : public QObject {
         THGoogleService (QObject *parent = 0);
         ~THGoogleService();
 
+        bool hasApiKey (void) const;
         QString apiKey (void) const;
         void setApiKey (const QString& apiKey);
 
+        bool hasHostLanguage (void) const;
         QString hostLanguage (void) const;
         void setHostLanguage (const QString& hl);
 
-        void get (const QUrl& url);
-        void get (const QNetworkRequest& request);
+        QNetworkReply *get (const QUrl& url);
+        QNetworkReply *get (const QNetworkRequest& request);
 
-        void post (const QUrl& url, QIODevice *data);
-        void post (const QUrl& url, const QByteArray& data);
-        void post (const QNetworkRequest& request, QIODevice *data);
-        void post (const QNetworkRequest& request, const QByteArray& data);
+        QNetworkReply *post (const QUrl& url, QIODevice *data);
+        QNetworkReply *post (const QUrl& url, const QByteArray& data);
+        QNetworkReply *post (const QNetworkRequest& request, QIODevice *data);
+        QNetworkReply *post (const QNetworkRequest& request, 
+                             const QByteArray& data);
 
         int responseStatus (void) const;
         QString errorString (void) const;
+        bool responseStatusIsError (void) const;
 
     Q_SIGNALS:
         void finished (bool error);
@@ -59,6 +63,7 @@ class THGoogleService : public QObject {
         virtual void responseReceived (QNetworkReply *reply);
 
     protected:
+        virtual void parseResponse (QNetworkReply *reply);
         virtual void parseResponse (const QByteArray& data);
 
     protected:
diff --git a/Google/src/googletranslator.cpp b/Google/src/googletranslator.cpp
index 358c58c..5819119 100644
--- a/Google/src/googletranslator.cpp
+++ b/Google/src/googletranslator.cpp
@@ -95,10 +95,11 @@ void THGoogleTranslator::translate (const QString& query) {
     url.addQueryItem("q", query);
     url.addQueryItem("v", "1.0");
     url.addQueryItem("langpair", d->srcLang + '|' + d->dstLang);
-    if (!hostLanguage().isEmpty())
+
+    if (hasHostLanguage())
         url.addQueryItem("hl", hostLanguage());
 
-    if (!apiKey().isEmpty())
+    if (hasApiKey())
         url.addQueryItem("key", apiKey());
 
     get(url);
diff --git a/Google/src/googleweather.cpp b/Google/src/googleweather.cpp
new file mode 100644
index 0000000..fefff87
--- /dev/null
+++ b/Google/src/googleweather.cpp
@@ -0,0 +1,341 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <QXmlStreamReader>
+#include <QHash>
+#include <QUrl>
+
+#include "googleweather.h"
+
+/* ============================================================================
+ *  PRIVATE Class and Structures
+ */
+typedef struct {
+    QString condition;
+    qreal high;
+    qreal low;
+} THGoogleWeatherForecast;
+
+typedef struct {
+    QString condition;
+    QString humidity;
+    QString wind;
+    qreal temp;
+} THGoogleWeatherConditions;
+
+class THGoogleWeatherPrivate {
+    public:
+        QHash<THGoogleWeather::DayOfWeek, THGoogleWeatherForecast> forecast;
+        THGoogleWeatherConditions current;
+        QString city;
+
+    public:
+        void clear (void);
+        qreal toCelsius (qreal fahrenheit) const;
+        THGoogleWeather::DayOfWeek parseDayOfWeek (const QStringRef& day) const;        
+};
+
+void THGoogleWeatherPrivate::clear (void) {
+    current.temp = 0.0f;
+    current.wind.clear();
+    current.humidity.clear();
+    current.condition.clear();
+
+    forecast.clear();
+}
+
+qreal THGoogleWeatherPrivate::toCelsius (qreal fahrenheit) const {
+    return(((fahrenheit - 32) * 5 + 8) / 9);
+}
+
+THGoogleWeather::DayOfWeek THGoogleWeatherPrivate::parseDayOfWeek (const QStringRef& day) const
+{
+    if (day == "Sun") return(THGoogleWeather::Sunday);
+    if (day == "Mon") return(THGoogleWeather::Monday);
+    if (day == "Tue") return(THGoogleWeather::Tuesday);
+    if (day == "Wed") return(THGoogleWeather::Wednesday);
+    if (day == "Thu") return(THGoogleWeather::Thursday);
+    if (day == "Fri") return(THGoogleWeather::Friday);
+    return(THGoogleWeather::Saturday); 
+}
+
+/* ============================================================================
+ *  PUBLIC Constructors/Destructor
+ */
+THGoogleWeather::THGoogleWeather (QObject *parent)
+    : THGoogleService(parent), d(new THGoogleWeatherPrivate)
+{
+}
+
+THGoogleWeather::~THGoogleWeather() {
+}
+
+/* ============================================================================
+ *  PUBLIC Properties
+ */
+QString THGoogleWeather::city (void) const {
+    return(d->city);
+}
+
+QString THGoogleWeather::dayOfWeek (DayOfWeek day) const {
+    switch (day) {
+        case Sunday:    return(tr("Sunday"));
+        case Monday:    return(tr("Monday"));
+        case Tuesday:   return(tr("Tuesday"));
+        case Wednesday: return(tr("Wednesday"));
+        case Thursday:  return(tr("Thursday"));
+        case Friday:    return(tr("Friday"));
+        case Saturday:  return(tr("Saturday"));
+    }
+
+    return(QString());
+}
+
+QString THGoogleWeather::currentCondition (void) const {
+    return(d->current.condition);
+}
+
+QString THGoogleWeather::currentHumidity (void) const {
+    return(d->current.humidity);
+}
+
+QString THGoogleWeather::currentWind (void) const {
+    return(d->current.wind);
+}
+
+qreal THGoogleWeather::currentTemperature (TemperatureUnit unit) const {
+    if (unit == Fahrenheit)
+        return(d->current.temp);
+    return(d->toCelsius(d->current.temp));
+}
+
+bool THGoogleWeather::hasForecast (DayOfWeek dayOfWeek) const {
+    return(d->forecast.contains(dayOfWeek));
+}
+
+QString THGoogleWeather::forecastCondition (DayOfWeek dayOfWeek) const {
+    if (!d->forecast.contains(dayOfWeek))
+        return(QString());
+    return(d->forecast.value(dayOfWeek).condition);
+}
+
+qreal THGoogleWeather::forecastLowTemperature (DayOfWeek dayOfWeek, 
+                                               TemperatureUnit unit) const
+{
+    if (!d->forecast.contains(dayOfWeek))
+        return(0.0f);
+
+    qreal temp = d->forecast.value(dayOfWeek).low;
+    return(unit == Fahrenheit ? temp : d->toCelsius(temp));
+}
+
+qreal THGoogleWeather::forecastHighTemperature (DayOfWeek dayOfWeek,
+                                                TemperatureUnit unit) const
+{
+    if (!d->forecast.contains(dayOfWeek))
+        return(0.0f);
+
+    qreal temp = d->forecast.value(dayOfWeek).high;
+    return(unit == Fahrenheit ? temp : d->toCelsius(temp));
+}
+
+bool THGoogleWeather::hasSundayForecast (void) const {
+    return(d->forecast.contains(Sunday));
+}
+
+QString THGoogleWeather::sundayCondition (void) const {
+    return(forecastCondition(Sunday));
+}
+
+qreal THGoogleWeather::sundayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Sunday, unit));
+}
+
+qreal THGoogleWeather::sundayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Sunday, unit));
+}
+
+bool THGoogleWeather::hasMondayForecast (void) const {
+    return(d->forecast.contains(Monday));
+}
+
+QString THGoogleWeather::mondayCondition (void) const {
+    return(forecastCondition(Monday));
+}
+
+qreal THGoogleWeather::mondayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Monday, unit));
+}
+
+qreal THGoogleWeather::mondayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Monday, unit));
+}
+
+bool THGoogleWeather::hasTuesdayForecast (void) const {
+    return(d->forecast.contains(Tuesday));
+}
+
+QString THGoogleWeather::tuesdayCondition (void) const {
+    return(forecastCondition(Tuesday));
+}
+
+qreal THGoogleWeather::tuesdayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Tuesday, unit));
+}
+
+qreal THGoogleWeather::tuesdayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Tuesday, unit));
+}
+
+bool THGoogleWeather::hasWednesdayForecast (void) const {
+    return(d->forecast.contains(Wednesday));
+}
+
+QString THGoogleWeather::wednesdayCondition (void) const {
+    return(forecastCondition(Wednesday));
+}
+
+qreal THGoogleWeather::wednesdayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Wednesday, unit));
+}
+
+qreal THGoogleWeather::wednesdayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Wednesday, unit));
+}
+
+bool THGoogleWeather::hasThursdayForecast (void) const {
+    return(d->forecast.contains(Thursday));
+}
+
+QString THGoogleWeather::thursdayCondition (void) const {
+    return(forecastCondition(Thursday));
+}
+
+qreal THGoogleWeather::thursdayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Thursday, unit));
+}
+
+qreal THGoogleWeather::thursdayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Thursday, unit));
+}
+
+bool THGoogleWeather::hasFridayForecast (void) const {
+    return(d->forecast.contains(Friday));
+}
+
+QString THGoogleWeather::fridayCondition (void) const {
+    return(forecastCondition(Friday));
+}
+
+qreal THGoogleWeather::fridayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Friday, unit));
+}
+
+qreal THGoogleWeather::fridayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Friday, unit));
+}
+
+bool THGoogleWeather::hasSaturdayForecast (void) const {
+    return(d->forecast.contains(Saturday));
+}
+
+QString THGoogleWeather::saturdayCondition (void) const {
+    return(forecastCondition(Saturday));
+}
+
+qreal THGoogleWeather::saturdayLowTemperature (TemperatureUnit unit) const {
+    return(forecastLowTemperature(Saturday, unit));
+}
+
+qreal THGoogleWeather::saturdayHighTemperature (TemperatureUnit unit) const {
+    return(forecastHighTemperature(Saturday, unit));
+}
+
+void THGoogleWeather::forecast (const QString& city) {
+    d->clear();
+
+	QUrl queryUrl("http://www.google.com/ig/api");
+	queryUrl.addQueryItem("hl", "en");
+	queryUrl.addQueryItem("weather", city);
+
+	get(queryUrl);
+}
+
+/* ============================================================================
+ *  PROTECTED Methods
+ */
+void THGoogleWeather::parseResponse (const QByteArray& data) {
+    QXmlStreamReader xmlReader(data);
+    while (!xmlReader.atEnd()) {
+        xmlReader.readNext();
+
+        if (!xmlReader.isStartElement())
+            continue;
+
+        if (xmlReader.name() == "city") {
+            d->city = xmlReader.attributes().value("data").toString();
+        } else if (xmlReader.name() == "current_conditions") {
+            while (!xmlReader.atEnd()) {
+                xmlReader.readNext();
+
+                if (!xmlReader.isStartElement()) {
+                    if (xmlReader.name() == "current_conditions")
+                        break;
+                    continue;
+                }
+
+                if (xmlReader.name() == "condition")
+                    d->current.condition = xmlReader.attributes().value("data").toString();
+                else if (xmlReader.name() == "temp_f")
+                    d->current.temp = xmlReader.attributes().value("data").toString().toFloat();
+                else if (xmlReader.name() == "humidity")
+                    d->current.humidity = xmlReader.attributes().value("data").toString();
+                else if (xmlReader.name() == "wind_condition")
+                    d->current.wind = xmlReader.attributes().value("data").toString();
+            }
+        } else if (xmlReader.name() == "forecast_conditions") {
+            THGoogleWeatherForecast forecast;
+            DayOfWeek dayOfWeek;
+
+            while (!xmlReader.atEnd()) {
+                xmlReader.readNext();
+
+                if (!xmlReader.isStartElement()) {
+                    if (xmlReader.name() == "forecast_conditions")
+                        break;
+                    continue;
+                }
+
+                if (xmlReader.name() == "day_of_week")
+                    dayOfWeek = d->parseDayOfWeek(xmlReader.attributes().value("data"));
+                else if (xmlReader.name() == "low")
+                    forecast.low = xmlReader.attributes().value("data").toString().toFloat();
+                else if (xmlReader.name() == "high")
+                    forecast.high = xmlReader.attributes().value("data").toString().toFloat();
+                else if (xmlReader.name() == "condition")
+                    forecast.condition = xmlReader.attributes().value("data").toString();
+            }
+
+            d->forecast.insert(dayOfWeek, forecast);
+        }
+    }
+
+    emit finished(false);
+}
+
diff --git a/Google/src/googleweather.h b/Google/src/googleweather.h
new file mode 100644
index 0000000..def4bdc
--- /dev/null
+++ b/Google/src/googleweather.h
@@ -0,0 +1,101 @@
+/* 
+ * Copyright (C) 2009 Matteo Bertozzi.
+ *
+ * This file is part of THLibrary.
+ * 
+ * THLibrary is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ * 
+ * THLibrary is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with THLibrary.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _THGOOGLEWEATHER_H_
+#define _THGOOGLEWEATHER_H_
+
+#include "googleservice.h"
+class THGoogleWeatherPrivate;
+
+class THGoogleWeather : public THGoogleService {
+    Q_OBJECT
+
+    public:
+        enum TemperatureUnit { Fahrenheit, Celsius };
+        enum DayOfWeek { 
+            Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday  
+        };
+
+    public:
+        THGoogleWeather (QObject *parent = 0);
+        ~THGoogleWeather();
+
+        QString city (void) const;
+
+        QString currentCondition (void) const;
+        QString currentHumidity (void) const;
+        QString currentWind (void) const;
+        qreal currentTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        QString dayOfWeek (DayOfWeek day) const;
+
+        bool hasForecast (DayOfWeek dayOfWeek) const;
+        QString forecastCondition (DayOfWeek dayOfWeek) const;
+        qreal forecastLowTemperature (DayOfWeek dayOfWeek, 
+                                      TemperatureUnit unit = Fahrenheit) const;
+        qreal forecastHighTemperature (DayOfWeek dayOfWeek,
+                                       TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasSundayForecast (void) const;
+        QString sundayCondition (void) const;
+        qreal sundayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal sundayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasMondayForecast (void) const;
+        QString mondayCondition (void) const;
+        qreal mondayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal mondayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasTuesdayForecast (void) const;
+        QString tuesdayCondition (void) const;
+        qreal tuesdayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal tuesdayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasWednesdayForecast (void) const;
+        QString wednesdayCondition (void) const;
+        qreal wednesdayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal wednesdayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasThursdayForecast (void) const;
+        QString thursdayCondition (void) const;
+        qreal thursdayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal thursdayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasFridayForecast (void) const;
+        QString fridayCondition (void) const;
+        qreal fridayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal fridayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+        bool hasSaturdayForecast (void) const;
+        QString saturdayCondition (void) const;
+        qreal saturdayLowTemperature (TemperatureUnit unit = Fahrenheit) const;
+        qreal saturdayHighTemperature (TemperatureUnit unit = Fahrenheit) const;
+
+    public Q_SLOTS:
+        void forecast (const QString& city);
+
+    protected:
+        void parseResponse (const QByteArray& data);
+
+    private:
+        THGoogleWeatherPrivate *d;
+};
+
+#endif /* !_THGOOGLEWEATHER_H_ */
+
diff --git a/Google/tests/ContactsTest/ContactsTest.pro b/Google/tests/ContactsTest/ContactsTest.pro
new file mode 100644
index 0000000..2d7e26a
--- /dev/null
+++ b/Google/tests/ContactsTest/ContactsTest.pro
@@ -0,0 +1,17 @@
+######################################################################
+# Automatically generated by qmake (2.01a) Wed Jun 24 21:51:09 2009
+######################################################################
+
+TEMPLATE = app
+TARGET = 
+DEPENDPATH += .
+INCLUDEPATH += . ../../src/
+
+DEFINES += TEST_GOOGLE_CONTACTS
+
+QT += testlib
+LIBS += -Wl,-rpath,../../lib -L../../lib -lTHGoogle
+
+# Input
+HEADERS += contactstest.h
+SOURCES += contactstest.cpp
diff --git a/Google/tests/ContactsTest/chess.jpg b/Google/tests/ContactsTest/chess.jpg
new file mode 100644
index 0000000000000000000000000000000000000000..7abb8a4d6a44d19c3c35894733e491ef352a0a1e
GIT binary patch
literal 3346
zcmb7@cQo7W|HeNNG1?fB#7JXPqqJrpF^X!<TCqw{dzF@oJ*%bmrXIqhMv&0jvsy~2
zQG3;RP}JU|Me)`1JHPY&`}?}jef@Kt>%QLSea?L`aWMxlYN~3e0w53wP`^CD#XP`#
z-`Cjz0JOCMVE_PVF7G85Q-BHp0aH>^f+3dzfk3FJp)}N&FkHP#3xzQ-F~JyMFgP=s
z1&%-=VK7#1RunrsCnqPIg@=!agAdKY$?@kA&}EdGikhB=hMoffLvZ}hT(kf%8o&y$
z0)uz}3K$3s16{NO>;OPPK>-H+-?V>}ng&7zP=YAHw3oIFBR~NHQ&57bC?S;KKlY_T
z34sAr)J)vsaAj)*kG{wABpQjkZ;&<>t%J-gyp`Cn<jW)*2mt@t&VRYgQ2>8B`C)%L
z|M364APN9X3F8)Lg7YXt^d+nZcP=IY=%q^m1H%ACz@#JgH|2a`le^yZEnMR_vk@vJ
z^G4Hs^oD8Lgcw(jIh4Lr0MijRACaZoR%Uma5^k7^A3F(WcDDR`iT8%M!>z5~FQ6-I
z^w`RK#mn(L`|V}f?%$@u%uMH#oE*|sp8mb0CV96kv@?}}w&e=-KN_`i`uMAmRH{9z
zVqaQYBdl-mH+ME6Nv{&Z_xyRhF}As156|^w+`!rn@&;D_!!u=f%<i{Wiz1y*6g0NG
z{)drhm<It$2y~ZSX@QR%G{*O~mMSV(DPUgdPs#Si;Rm?-itaRiedaZ8A?qdZF33Tr
z{O368$gay0HMKGBcI;TQMOzd-Wr8j59Vj>M!CMxUi*_>*@uv^DrkVs?m94AV_?Ulz
zpQ+N?NN92TMG5ewyvt5}9e+Rhw(#1sQhFLicKIpqMzV+dR)0_qEpPhUC_eX|*jm}7
z6&>{hUQK(~QWKo~mw$yvHx!0loP3ZuF2yUn=?{s!-5NAYJxHsNR6K@V&RIm_w!il<
zyaQQ}b<N7YCpC=BQC~GvDxzUsOb(_LdURF|;JgfCN$@xG?k_8{#u{^AqgvWurEYc!
z+!Exj82HI);oRe&EE~2C`~WvRY3N|s9L9|zq&46va5Q+r1+}EZY}8(1pXy0(J#6IS
zz56RC4?_dqIP1CqzSBv+_xy~i-u}*^A1a=x&S9!>u3~xPW&^26-Ff9Dwv;ro)|twQ
zUtIJ;?Ep^RbampfA#t__R+`e?^)>)y%7CreufxHRor)Ur)_bKG555@fr&XTvRkBpj
zjY1<Tf5#HcUdul3T{ppRuWsH$s$aoqAjtGD#adBoVgc+N7XS;+e?h^BYBM_5Xh@AU
zzqsAn@_Lt@jZ&9!A5{SCcbnFnLw}G1@kr2G@`wGD(}vk*Yfxb|HX}c$Fq*76p&zQz
zKj7y)`7P`2KaV%e6dJT}Mk4s`7Wr7e%Jz!Q=dmdX51bABY@kpl!}#2zj#vU0sovtq
zZFKFeQ4NzpAG5@M6%w1D+qGFh7dsb;dps~9;TW{xa&;!%MR>ByHc>GSS}Ah{O#!&3
zY!Oyq{OMOTqnx98t9A4$8N1bGzVOzMlKqTE4TgtlE&Vbzqf(c;zEH@6f6Bt2h#tBZ
zmXY$_5Q*WruAaT6!HNvTiUh5hU5)JuXAT`l;(0tNImtS=PIFz1M>AaSp6y&P8;7IH
z<5!^;SX1}G(|Qql#p6-pKaq8Wx@zO0{oph+^Vqd_^?XM!qwD81<oBwhS%BLrX#ar8
zsyN(8xK6=z7Ithh<yL@d;`GY*!qVJy=_n1&1P3ct+q|U=e18V@hxdPZiPrX`I=<xP
z8TAIX&1|od&oVsCitRf5R`Z@V(izL-93(1GzD7wL^!Mg)vFpDw_qPkthKT&M3wHyZ
z2QTmkJv_CvmyMST7@{gomrkwdjCe+KvhXfAC)3(jxxMe2Yx8S0x8ky_Nzg4pGY4UQ
zhqc}SG!*ckqZ9U$rr+0??-Gn`5N2y!7&n<o`_#PDu)_U*5I2uNw<a1H{&KMXhf8*0
zyoiVoAQxN!H}hiLUOK6^`8+B;&3CdWJA|g_o8at)u1l~?i=tmFw&GR`wjM+9j(abN
zjc)mpuH9>LZV+KDgdh`KQqosl;+~byofTGv);qof$$4qW=q`|PAH8a!&7>i_SA()1
z+onkMo*fPKxa!lkLovC#C*1^+<D-v)7l15mMB9}OU{>rQUJI-BsoR;<5GYEfy}|Dn
z`wS|^j&NK7ovb6`GI0GJP@i^72y51-<%jF0x;oQqG#9{|q213~>V?fAOi^99D8*ew
ztEyhZ`Z8fzJNszzvC!7YRhB4T;gOd5wSG1Q>JsCSw^DVx@#@Rus#a8*{ZYLAjj$rx
zS=Ha(pV#uYZY3(`Zm&^^NBRGxu9X%DCi<J91ZOcnQtNa_I8!fxas9mma-x6s!@9?v
zhN<E$-F@8jEd;B2y0b%P1mn~N(2yK8$T(iHBD__;x$Y$nB9*Kz#PwTmh4cN6d|I0k
zFiRs7a(fbIbUwrH%O$BZ+^Eh;J&P>>O&@gJ!3=G-(sfEPH#h0h2~<ySjzY^2uBF?w
z?j~SNpGD`>h`-&wnLaBnQcCPL4Q=VjcL1wYaolMyG6;CA$8ZR<ly<dlD?2l>)`)Wh
z=Z)%p<!aLaJEAAfl*mH74Oq1x_Ik&5jd$sS+y#gvU$O8VGciAm+7f$Hi1yWwaM<ki
z@2<O+oBM;m5U|f`->rUCP%O%{@<MtReztxYRdmqxte)Kzb>*FO5oY4Pc8>iVYJR3u
zTzKb1Ib=ksq3m4zZRt!?`ix`I+nQ(@VzNoRDkB3Ppy>#9R0+s5e}b$s9+$iPNK(nS
zfgX6WyR1{b0`UXc#?U6rsEnA2Sqi0hQ10$t7>7gztEn8@rRf^lpSVZ}=`Y+EGmMKG
z>Zu{QY)h5vYkZf}ED*Asz;qo9>zX@8OhWZKbZ?mlen7#_uQ6X~GV<!H{;MWH_vPEO
zFo?nPoi&}{%$w6LCApFNBOR*pS+YZP^j2GLwYjgo&HoapLF7{ax<Br>o~}STBB@Uc
zYL_x}c87Wlc#rorF^wk+oIw&zWOvh5Evb|u-H23$eqUS>Qytypbeujqw!1Lv3(!D4
zKdgIxJ@=WiKyi*i;!B2l8S>rNw90$7B>`U>U7~MTd}4W`8Ld<*IcO$fdt?6-+4i`z
zQ@^IqtmZgTsNX_!pvS|l!2k_%2#fF{w0op6(W`na$Cg?h?px@~?(qnT5Ev+in*#mg
z-G|x-+l1Bi=TqL8P!Bvm=p*#t$4SlMPsqvh#-j#Q#*Qtv+l-Q@&d3QV>8AXkZ{Bmo
z{`cy~)F=~Jp<hb>-3P5mcpVs;xgCjCxm9&aiXdQo9!<%8tx9aR@dXQfYfl#yg3&&x
zj{R?Ex`e;VMm?HMvf}<Fk!s7I_w)6c6TI03>WH;R@<_QD@2RrE^w=J~0*PSj7laq9
zaTXsLr%*jLzM%){p0ZQqT;xs^98K7oPtwf{E8_5#!E|W*yz)U#UCT_~))tS~bjBoA
zO0NGzy|LWTGu*LxxBG89{zzp8^_JVnf-5fT{BB%?Rlwn|wU`gLH=m3(og%GGc@jN`
zdq1Wd_J^qKqE@YE4vY}x(<?U(YD85kOFf3G!>{Zu+WQB;yYsQOuKqc`@cm?&7Qey+
zY&-uWW@oV>Az`&f1|`{(H3-SYL3KkjV|$rs85=)8HWxt0{{Vj|#^r~}xvk?$01@aL
zR!c0}+BL`Ta@Xh^;(zxBil5Pk)%tf9mQaZ)*^by^M!$}ChDt&g?Ho(Sb60#=@s!(G
zc<@#?sR!B0ACVq4nf>V(>=mZ<%tHKVK=sp3>ysRt8_-@qPjp~Uf;swpQf%vrIv+8O
z;g&d-ib|)rd^3_HiNea*_*3%14^SasLA~~j934zKou;&X;QbS9ZLo-VS&Zm|kL_IQ
zF=`7b@NiINJm#U*F{4hTAzFBMT7IWm*#Czb=9FQZoHIM&y{;{nf$-#rctop`ki_-R
zEG}@)|AqPO({P4Q?--8K8vD<QVKYn?d}#~uMAwRY>|!sMU-v6S9XrkVrAORbBIob`
zd$JTed&!3mc}^Qy5yb2V;hAiM4yppZ%f%<Q*zv~+j0FOjIB3iTkgR_v#82u)W#zU<
zXe@nb%Cyzgsa&A@`Lc6y?om@360whSOrTKbHx#K4;pc<C7)T%{tsD1$FjV)misx6D
z)VOx)Gpu5wAF^}(T);iscJYbRLgaloesh<1on!&U#~4?1AKMP_`Sk@h2cOKaR3;!Z
zT-|kgXXb+t=>e2dMm4%JrmUo*Ml!(;vUhyEX1w5CRFY)o+J+8Zd&U02cZ}R+==57w
rM*e0lz#@8d0bs_O6(UU03g+Q~JG$Z*09d*FmCaYy5(+xni*Nq{by)+h

literal 0
HcmV?d00001

diff --git a/Google/tests/ContactsTest/contactstest.cpp b/Google/tests/ContactsTest/contactstest.cpp
new file mode 100644
index 0000000..291c9a6
--- /dev/null
+++ b/Google/tests/ContactsTest/contactstest.cpp
@@ -0,0 +1,196 @@
+#ifdef TEST_GOOGLE_CONTACTS
+
+#include <QtTest>
+
+#include <QXmlStreamWriter>
+#include <QDebug>
+
+#include "contactstest.h"
+
+#include "googlecontacts.h"
+#include "googleauth.h"
+
+#define GOOGLE_USERNAME         "USER@gmail.com"
+#define GOOGLE_PASSWORD         "PASSWORD"
+
+ContactsTest::ContactsTest (QObject *parent)
+    : QObject(parent)
+{
+    QEventLoop l;
+    THGoogleAuth gAuth(GOOGLE_USERNAME);
+    connect(&gAuth, SIGNAL(authenticated()), &l, SLOT(quit()));
+    gAuth.login(THGoogleAuth::Contacts, GOOGLE_PASSWORD);
+    l.exec();
+
+    m_contact = NULL;
+    if (gAuth.error() != THGoogleAuth::NoError) {
+        qDebug() << "AUTH FAILED" << gAuth.errorString();
+        m_gContacts = NULL;
+    } else {
+        // Setup Google Contacts Service
+        m_gContacts = new THGoogleContactsService;
+        m_gContacts->setAuthToken(gAuth.auth());
+    }
+}
+
+ContactsTest::~ContactsTest() {
+    if (m_contact != NULL)
+        delete m_contact;
+    delete m_gContacts;
+}
+
+void ContactsTest::testInsert (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+
+    // Setup Contact
+    m_contact = new THGoogleContact;
+    m_contact->setFullName("John Doe");
+
+    THGoogleIm *im = new THGoogleIm;
+    im->setRel(THGoogleIm::relWork());
+    im->setAddress("john.doe@mac.com");
+    im->setProtocol(THGoogleIm::protocolAim());
+    m_contact->addImAddress(im);
+
+    THGoogleEmail *email = new THGoogleEmail;
+    email->setAddress("john.doe@th3sft.com");
+    email->setRel(THGoogleEmail::relWork());
+    m_contact->addEmailAddress(email);
+
+    email = new THGoogleEmail;
+    email->setAddress("john.doe@gmail.com");
+    email->setRel(THGoogleEmail::relHome());
+    m_contact->addEmailAddress(email);
+
+    // Add Extended Property
+    m_contact->addUserDefinedField("TestCode", "1289005");
+
+    // Insert Contact
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->insertContact(m_contact);
+    l.exec();
+
+    qDebug() << m_gContacts->errorString();
+    qDebug() << m_contact->id();
+    qDebug() << m_contact->etag();
+}
+
+void ContactsTest::testUpdate (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+    QVERIFY2(m_contact != NULL, "Contact not Found");
+
+    // Setup Contact
+    THGoogleIm *im = new THGoogleIm;
+    im->setRel(THGoogleIm::relWork());
+    im->setAddress("john.doe@jabber.com");
+    im->setProtocol(THGoogleIm::protocolJabber());
+    m_contact->addImAddress(im);
+
+    // Update Contact
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->updateContact(m_contact);
+    l.exec();
+
+    qDebug() << m_gContacts->errorString();
+    qDebug() << m_contact->id();
+    qDebug() << m_contact->etag();
+}
+
+void ContactsTest::testUpdatePhoto (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+    QVERIFY2(m_contact != NULL, "Contact not Found");
+
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->addContactPhoto(m_contact, QImage("chess.jpg"));
+    l.exec();
+}
+
+void ContactsTest::testInsertGroup (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+
+    m_group = new THGoogleContactGroup;
+    m_group->setTitle("Test Qt Group");
+
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->insertGroup(m_group);
+    l.exec();
+}
+
+void ContactsTest::testUpdateGroup (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+    QVERIFY2(m_contact != NULL, "Contact not Found");
+    QVERIFY2(m_group != NULL, "Group not Found");
+
+    THGoogleGroupMembershipInfo *groupMembership = new THGoogleGroupMembershipInfo;
+    groupMembership->setHref(m_group->id());
+    m_contact->addGroupMembershipInfo(groupMembership);
+
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->updateContact(m_contact);
+    l.exec();
+}
+
+void ContactsTest::testAllContacts (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->retrieveAllContacts();
+    l.exec();
+
+    foreach (THGoogleContact *contact, m_gContacts->contactList())
+        qDebug() << contact->fullName();
+}
+
+void ContactsTest::testAllGroups (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->retrieveAllGroups();
+    l.exec();
+
+    foreach (THGoogleContactGroup *group, m_gContacts->groupList())
+        qDebug() << group->title();
+}
+
+#define ENABLE_DELETION
+void ContactsTest::testDelete (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+    QVERIFY2(m_contact != NULL, "Contact not Found");
+
+#ifdef ENABLE_DELETION
+    m_contact->setDeleted(true);
+
+    // Update Contact
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->deleteContact(m_contact);
+    l.exec();
+#endif
+}
+
+void ContactsTest::testDeleteGroup (void) {
+    QVERIFY2(m_gContacts != NULL, "Authentication Failed");
+    QVERIFY2(m_group != NULL, "Group not Found");
+
+#ifdef ENABLE_DELETION
+    m_group->setDeleted(true);
+
+    // Update Contact
+    QEventLoop l;
+    connect(m_gContacts, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    m_gContacts->deleteGroup(m_group);
+    l.exec();
+#endif
+}
+
+QTEST_MAIN(ContactsTest)
+
+#endif /* TEST_GOOGLE_CONTACTS */
+
diff --git a/Google/tests/ContactsTest/contactstest.h b/Google/tests/ContactsTest/contactstest.h
new file mode 100644
index 0000000..651a3e7
--- /dev/null
+++ b/Google/tests/ContactsTest/contactstest.h
@@ -0,0 +1,39 @@
+#ifdef TEST_GOOGLE_CONTACTS
+#ifndef _CONTACTS_TEST_H_
+#define _CONTACTS_TEST_H_
+
+#include <QObject>
+class THGoogleContactsService;
+class THGoogleContactGroup;
+class THGoogleContact;
+
+class ContactsTest : public QObject {
+    Q_OBJECT
+
+    public:
+        ContactsTest (QObject *parent = 0);
+        ~ContactsTest();
+
+    private slots:
+        void testInsert (void);
+        void testUpdate (void);
+        void testUpdatePhoto (void);
+
+        void testInsertGroup (void);
+        void testUpdateGroup (void);
+
+        void testAllContacts (void);    
+        void testAllGroups (void);
+
+        void testDelete (void);
+        void testDeleteGroup (void);
+
+    private:
+        THGoogleContactsService *m_gContacts;
+        THGoogleContactGroup *m_group;
+        THGoogleContact *m_contact;
+};
+
+#endif /* !_CONTACTS_TEST_H_ */
+#endif /* !TEST_GOOGLE_CONTACTS */
+
diff --git a/Google/tests/ServicesTest/ServicesTest.pro b/Google/tests/ServicesTest/ServicesTest.pro
new file mode 100644
index 0000000..0bf1732
--- /dev/null
+++ b/Google/tests/ServicesTest/ServicesTest.pro
@@ -0,0 +1,17 @@
+######################################################################
+# Automatically generated by qmake (2.01a) Wed Jun 24 21:42:17 2009
+######################################################################
+
+TEMPLATE = app
+TARGET = 
+DEPENDPATH += .
+INCLUDEPATH += . ../../src/
+
+DEFINES += TEST_GOOGLE_SERVICES
+
+QT += testlib
+LIBS += -Wl,-rpath,../../lib -L../../lib -lTHGoogle
+
+# Input
+HEADERS += servicestest.h
+SOURCES += servicestest.cpp
diff --git a/Google/tests/ServicesTest/servicestest.cpp b/Google/tests/ServicesTest/servicestest.cpp
new file mode 100644
index 0000000..e3b05f2
--- /dev/null
+++ b/Google/tests/ServicesTest/servicestest.cpp
@@ -0,0 +1,164 @@
+#ifdef TEST_GOOGLE_SERVICES
+
+#include <QtTest>
+
+#include <QStringList>
+#include <QEventLoop>
+#include <QDebug>
+
+#include "googledetectlanguage.h"
+#include "googlespellchecker.h"
+#include "googletranslator.h"
+#include "googlegeocoding.h"
+#include "googleweather.h"
+#include "googlesuggest.h"
+#include "googleauth.h"
+
+#include "servicestest.h"
+
+#define GOOGLE_USERNAME         "USER@gmail.com"
+#define GOOGLE_PASSWORD         "PASSWORD"
+
+ServicesTest::ServicesTest (QObject *parent)
+    : QObject(parent)
+{
+}
+
+ServicesTest::~ServicesTest() {
+}
+
+void ServicesTest::testAuth (void) {
+    QEventLoop l;
+    THGoogleAuth gAuth(GOOGLE_USERNAME);
+    connect(&gAuth, SIGNAL(authenticated()), &l, SLOT(quit()));
+    gAuth.login(THGoogleAuth::Contacts, GOOGLE_PASSWORD);
+    l.exec();
+
+    if (gAuth.error() == THGoogleAuth::NoError) {
+        qDebug() << "SID" << gAuth.sid();
+        qDebug() << "LSID" << gAuth.lsid();
+        qDebug() << "AUTH" << gAuth.auth();
+    } else {
+        qDebug() << gAuth.errorString();
+    }
+
+    QVERIFY(1);     // Do some test...
+}
+
+void ServicesTest::testWeather (void) {
+    QEventLoop l;
+    THGoogleWeather gWeather;
+    connect(&gWeather, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    gWeather.forecast("San Mateo, CA");
+    l.exec();
+
+    qDebug() << gWeather.city() << "Forecast";
+    qDebug() << "Current:" << gWeather.currentCondition();
+    qDebug() << gWeather.currentHumidity();
+    qDebug() << gWeather.currentWind();
+    qDebug() << gWeather.currentTemperature(THGoogleWeather::Celsius);
+
+    for (int i = THGoogleWeather::Sunday; i <= THGoogleWeather::Saturday; ++i) {
+        THGoogleWeather::DayOfWeek day = (THGoogleWeather::DayOfWeek)i;
+        if (!gWeather.hasForecast(day))
+            continue;
+
+        qDebug() << gWeather.dayOfWeek(day) << gWeather.forecastCondition(day);
+        qDebug() << " - Low Temperature" << gWeather.forecastLowTemperature(day, THGoogleWeather::Celsius);
+        qDebug() << " - High Temperature" << gWeather.forecastHighTemperature(day, THGoogleWeather::Celsius);
+    }
+}
+
+void ServicesTest::testGeoCoding (void) {
+    QEventLoop l;
+    THGoogleGeocoding gGeoCoder;
+    connect(&gGeoCoder, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    gGeoCoder.request("Asola");
+    l.exec();
+
+    foreach (THGoogleGeoPlacemark placemark, gGeoCoder.placemarks()) {
+        qDebug() << placemark.east() 
+                 << placemark.west() 
+                 << placemark.north() 
+                 << placemark.south() 
+                 << placemark.address() 
+                 << placemark.coordinates() 
+                 << placemark.countryName() 
+                 << placemark.countryCode() 
+                 << placemark.localityName() 
+                 << placemark.postalCodeNumber() 
+                 << placemark.thoroughfareName() 
+                 << placemark.administrativeAreaName()
+                 << placemark.subAdministrativeAreaName();
+    }
+
+    QVERIFY(1);     // Do some test...
+}
+
+void ServicesTest::testTranslator (void) {
+    QEventLoop l;
+
+    THGoogleTranslator gTranslator;
+    connect(&gTranslator, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    gTranslator.setDestinationLanguage("en");
+    gTranslator.translate("Ciao");
+
+    l.exec();
+
+    qDebug() << gTranslator.query();
+    qDebug() << gTranslator.translatedText();
+    qDebug() << gTranslator.detectedSourceLanguage();
+
+    QVERIFY(1);     // Do some test...
+}
+
+void ServicesTest::testSuggestions (void) {
+    QEventLoop l;
+
+    THGoogleSuggest gSuggest;
+    connect(&gSuggest, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    gSuggest.suggest("Qt Softw");
+
+    l.exec();
+
+    qDebug() << gSuggest.suggestions();
+
+    QVERIFY(1);     // Do some test...
+}
+
+void ServicesTest::testSpellChecker (void) {
+    QEventLoop l;
+
+    THGoogleSpellChecker gSpellChecker;
+    connect(&gSpellChecker, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    gSpellChecker.spellCheck("Gogl Spll");
+
+    l.exec();
+
+    foreach (QString original, gSpellChecker.keys())
+        qDebug() << original << gSpellChecker.suggestions(original);
+
+    QVERIFY(1);     // Do some test...
+}
+
+void ServicesTest::testLanguageDetection (void) {
+    QEventLoop l;
+
+    THGoogleDetectLanguage gDetectLang;
+    connect(&gDetectLang, SIGNAL(finished(bool)), &l, SLOT(quit()));
+    gDetectLang.detectLanguage("Ciao");
+
+    l.exec();
+
+    qDebug() << "Query" << gDetectLang.query();
+    qDebug() << "Language" << gDetectLang.language();
+    qDebug() << "Is Reliable" << gDetectLang.isReliable();
+    qDebug() << "Confidence" << gDetectLang.confidence();
+
+    QVERIFY(1);     // Do some test...
+}
+
+QTEST_MAIN(ServicesTest)
+
+#endif /* TEST_GOOGLE_SERVICES */
+
diff --git a/Google/tests/ServicesTest/servicestest.h b/Google/tests/ServicesTest/servicestest.h
new file mode 100644
index 0000000..a3f0dce
--- /dev/null
+++ b/Google/tests/ServicesTest/servicestest.h
@@ -0,0 +1,25 @@
+#ifdef TEST_GOOGLE_SERVICES
+#ifndef _SERVICES_TEST_H_
+#define _SERVICES_TEST_H_
+
+#include <QObject>
+
+class ServicesTest : public QObject {
+    Q_OBJECT
+
+    public:
+        ServicesTest (QObject *parent = 0);
+        ~ServicesTest();
+
+    private slots:
+        void testAuth (void);
+        void testWeather (void);
+        void testGeoCoding (void);
+        void testTranslator (void);
+        void testSuggestions (void);
+        void testSpellChecker (void);
+        void testLanguageDetection (void);
+};
+
+#endif /* !_SERVICES_TEST_H_ */
+#endif /* TEST_GOOGLE_SERVICES */
-- 
1.6.0.4

